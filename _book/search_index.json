[
["index.html", "Introdução a R para Visualização e Apresentação de Dados Boas-vindas Sobre o instrutor Referências", " Introdução a R para Visualização e Apresentação de Dados Sillas Gonzaga 2018-08-19 Boas-vindas Sejam bem-vindos ao maravilhoso mundo da Visualização de Dados em R! Neste curso, você conhecerá uma das melhores ferramentas para produção de gráficos já criadas: o pacote ggplot2. Dominá-lo, que é um dos objetivos deste curso, fará você ser capaz de fazer gráficos elegantes e informativos, que o auxiliará a transmitir suas ideias com maior clareza. Primeiramente, iremos introduzir (ou revisar, caso você felizmente já conheça) o tidyverse, uma suíte de pacotes de R que revolucionou a maneira como usuários da linguagem fazem suas análises. Você irá usar pacotes como readr, dplyr e tidyr para ler, manusear e estruturar dados públicos, além de praticar as habilidades aprendidas em um divertido conjunto de dados sobre super-heróis. Após entender a fundo como funciona o ggplot2 nos capítulos 2 e 3 iremos mostrar, como criar outros tipos de visualizações, como gráficos interativos e mapas. Finalmente, você será apresentado ao mundo do rmarkdown, se tornando capaz de produzir relatórios e apresentações de alta qualidade de modo reprodutível. Sobre o instrutor Meu nome é Sillas e sou apaixonado pelo R. Venho praticando nessa linguagem desde 2014 e, desde então, criei um blog chamado Paixão por Dados, já dei palestras sobre minha carreira com R e já publiquei 4 pacotes R. Referências Referências: Capítulo “Data visualisation” do livro R for Data Science Livro online Data Visualization A practical introduction "],
["breve-introducao-ao-r.html", "Módulo 1 Breve introdução ao R 1.1 Objetivo 1.2 Introdução ao R 1.3 Leitura de dados com readr 1.4 dplyr 1.5 Juntando duas tabelas em uma 1.6 tidyr 1.7 Exercícios", " Módulo 1 Breve introdução ao R 1.1 Objetivo Revisar conceitos, pacotes e funções fundamentais na linguagem R para executar tarefas como: * Importar um conjunto de dados de um arquivo; * Selecionar ou remover colunas; * Filtrar linhas de um conjunto de dados de acordo com uma ou mais condições; * Agrupar e sumarizar dados; * Manipular estruturas de dados, mudando seus formatos; * Operações básicas com datas 1.2 Introdução ao R O R é uma linguagem de programação inicialmente criada para fins estatísticos mas que, com o crescimento de sua popularidade, aumentou o seu escopo, sendo hoje uma das melhores ferramentas existentes para tarefas como automação de tarefas, web scraping, desenvolvimento de web apps e principalmente visualização de dados. Um dos maiores marcos no universo R foi a criação do pacote ggplot2, desenvolvido principalmente por Hadley Wickham, que implementou a abordagem da Gramática dos Gráficos. O ggplot2 faz parte do tidyverse, que é uma suíte de pacotes R criadas e mantidas também por Hadley Wickham para realizar todo o pipeline de um projeto de análise de dados de maneira harmônica. Durante o restante da aula, usaremos muitos pacotes da suíte tidyverse. Por isso, importe o pacote usando o comando usual: library(tidyverse) # install.packages(&quot;tidyverse&quot;) # chequem se a versao dos seus pacotes é a mesma das minhas # devtools::session_info() # sessionInfo() 1.3 Leitura de dados com readr O primeiro ponto de qualquer projeto de análise de dados é obter os dados. Muitas das vezes, os dados são fornecidos em arquivos locais em formatos como .csv, .xlsx, .txt., etc. O R possui funções nativas para ler certos arquivos de dados, mas o pacote readr possui recursos mais otimizados. Para este módulo, utilizaremos como base de dados de exercícios o dataset de Despesas do Governo de Alagoas, que tem se destacado por suas iniciativas de dados abertos. Veja que o próprio processo de download dos dados pode ser feito com R: # salvar url de download no objeto link link &lt;- &quot;http://transparencia.al.gov.br/media/arquivo/comparativo_despesas-2017.zip&quot; # criar pasta chamada data para armazenar o arquivo dir.create(&quot;data/&quot;) # realizar o download do arquivo download.file(link, destfile = &quot;data/desp_al_2017.zip&quot;) # descompactar o arquivo na pasta data unzip(&quot;data/desp_al_2017.zip&quot;, exdir = &quot;data/&quot;) # Importando o arquivo de 2017 # usamos a função read_delim porque o arquivo vem separado por # barras verticais (|) # alem disso, precisamos especificar o locale para caracteres especiais # serem importados corretamente para o R df_despesas &lt;- read_delim(&quot;data/comparativo_despesas-2017.txt&quot;, delim = &quot;|&quot;, locale = locale(encoding = &quot;ISO-8859-1&quot;), # progress = FALSE, para nao mostrar a barra de progresso progress = FALSE) # exibir as 6 primeiras linhas do arquivo importado head(df_despesas) ## # A tibble: 6 x 44 ## ANO MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 2 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 3 2017 12 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 4 2017 7 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 5 2017 6 5400… SEC DE ESTA… 00001 0618… MANUTENCAO … 0100 ## 6 2017 10 5400… POLICIA MIL… 00001 0618… MANUTENCAO … 0100 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; Na função read_delim acima, precisamos especificar três argumentos: * o nome do arquivo a ser importado * o caracter usado para separar colunas (normalmente é ponto-e-vírgula) * o locale (encoding), muitas vezes necessários ao trabalhar com Linux com arquivos brasileiros Referências: Documentação do pacote readr Documentação do pacote readxl, ideal para ler arquivos de Excel. Capítulo “Lendo os dados” do livro Ciência de Dados com R Capítulo “Data import” do livro R for Data Science 1.4 dplyr O pacote dplyr é o mais usado para as mais variadas tarefas de manuseio de dados: agregar, sumarizar, filtrar, ordenar, criar variáveis, joins, dentre outras. Vamos continuar usando o dataset das despesas do estado de Alagoas para demonstrar o uso das principais funções do dplyr Materiais mais completos sobre o pacote dplyr podem ser encontrados nas referências abaixo: Referências: Site oficial do pacote dplyr Capítulo “Manipulando os dados” do livro Ciência de Dados com R Capítulo “Data transformation” do livro R for Data Science Documentação do pacote dplyr 1.4.1 select() Select é uma função muito simples: serve para selecionar ou remover colunas. # Tarefa: selecionar colunas ANO, UG e GESTAO, mudando o nome da última df_despesas %&gt;% select(ANO = ANO, UG, CODIGO_GESTAO = GESTAO) %&gt;% head() ## # A tibble: 6 x 3 ## ANO UG CODIGO_GESTAO ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 510556 51556 ## 2 2017 510556 51556 ## 3 2017 540033 00001 ## 4 2017 540033 00001 ## 5 2017 540033 00001 ## 6 2017 540034 00001 # tarefa: remover coluna ANO df_despesas %&gt;% select(-ANO) %&gt;% head() ## # A tibble: 6 x 43 ## MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 2 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 3 12 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 4 7 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 5 6 5400… SEC DE ESTA… 00001 0618… MANUTENCAO … 0100 ## 6 10 5400… POLICIA MIL… 00001 0618… MANUTENCAO … 0100 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # tarefa: selecionar todas as colunas numéricas df_despesas %&gt;% select_if(is.numeric) %&gt;% head() ## # A tibble: 6 x 21 ## ANO MES NATUREZA1 NATUREZA2 NATUREZA3 NATUREZA4 NATUREZA5 NATUREZA6 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2017 11 300000000 330000000 331000000 331900000 331900000 331901100 ## 2 2017 11 300000000 330000000 331000000 331900000 331900000 331901100 ## 3 2017 12 300000000 330000000 333000000 333900000 333900000 333903900 ## 4 2017 7 300000000 330000000 333000000 333900000 333900000 333903900 ## 5 2017 6 300000000 330000000 333000000 333900000 333900000 333903100 ## 6 2017 10 300000000 330000000 333000000 333900000 333900000 333903900 ## # ... with 13 more variables: NATUREZA &lt;int&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, ## # PROGRAMA_ID &lt;int&gt;, SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, ## # FONTE_MAE_ID &lt;int&gt;, FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, ## # FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, VALOR_EMPENHADO &lt;dbl&gt;, ## # VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # tarefa: selecionar apenas as colunas cujo nome começa com VALOR df_despesas %&gt;% select(starts_with(&quot;VALOR&quot;)) %&gt;% head() ## # A tibble: 6 x 3 ## VALOR_EMPENHADO VALOR_LIQUIDADO VALOR_PAGO ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 25557. 25557. 25557. ## 2 36652. 36652. 36652. ## 3 84031. 0 78990. ## 4 173834. 0 0 ## 5 292. 292. 0 ## 6 38072. 0 0 Referências: Documentação da função select() 1.4.2 filter() filter() permite que você crie filtros de observações baseado em um ou mais critérios. Os critérios podem ser construídos com os operadores lógicos &gt;, &gt;=, &lt;, &lt;=, != e ==, ou com funções que retornam uma booleana (resultado lógico, TRUE ou FALSE). # tarefa: filtrar as linhas onde o valor da coluna VALOR_EMPENHADO é maior que 100000 df_despesas %&gt;% filter(VALOR_EMPENHADO &gt; 100000) %&gt;% head() ## # A tibble: 6 x 44 ## ANO MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 7 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 2 2017 5 5400… POLICIA MIL… 00001 0618… MANUTENCAO … 0100 ## 3 2017 4 5400… SEC DE ESTA… 00001 0684… CONTRIBUICA… 0100 ## 4 2017 10 5400… CORPO DE BO… 00001 0612… MANUTENCAO … 0100 ## 5 2017 1 9109… ENCARGOS GE… 00001 2884… SERVICOS DA… 0100 ## 6 2017 8 5400… POLICIA CIV… 00001 0618… MANUTENCAO … 0100 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # tarefa: filtrar as linhas onde o ANO é o mesmo do atual df_despesas %&gt;% filter(ANO == lubridate::year(lubridate::today())) ## # A tibble: 0 x 44 ## # ... with 44 variables: ANO &lt;int&gt;, MES &lt;int&gt;, UG &lt;chr&gt;, ## # DESCRICAO_UG &lt;chr&gt;, GESTAO &lt;chr&gt;, PT &lt;chr&gt;, PT_DESCRICAO &lt;chr&gt;, ## # FONTE_MAE &lt;chr&gt;, DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # tarefa: filtrar as linhas de Junho/2017 df_despesas %&gt;% filter(ANO == 2017, MES &gt; 6) %&gt;% head() ## # A tibble: 6 x 44 ## ANO MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 2 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 3 2017 12 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 4 2017 7 5400… SEC DE ESTA… 00001 0612… MANUTENCAO … 0100 ## 5 2017 10 5400… POLICIA MIL… 00001 0618… MANUTENCAO … 0100 ## 6 2017 7 5305… DEPARTAM DE… 53538 2612… MANUTENCAO … 0291 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # Tarefa: filtrar as linhas dentro de um intervalo de datas (inclusivo) df_despesas %&gt;% filter(between(DATA_REGISTRO, as.Date(&quot;2017-11-15&quot;), as.Date(&quot;2017-12-15&quot;))) %&gt;% head() ## # A tibble: 6 x 44 ## ANO MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 2 2017 11 5105… UNIVERS EST… 51556 1030… MANUTENCAO … 0100 ## 3 2017 11 5400… POLICIA MIL… 00001 0618… MANUTENCAO … 0100 ## 4 2017 12 5400… SEC DE ESTA… 00001 0618… MANUTENCAO … 0100 ## 5 2017 12 5205… FUNDO ESTAD… 52534 2312… MANUTENCAO … 0100 ## 6 2017 11 5400… POLICIA CIV… 00001 0618… MANUTENCAO … 0100 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # tarefa: filtrar fora todas os dados que são de 2017 # em outras palavras: filtrar os dados que não são de 2017 df_despesas %&gt;% filter(ANO != 2017) ## # A tibble: 0 x 44 ## # ... with 44 variables: ANO &lt;int&gt;, MES &lt;int&gt;, UG &lt;chr&gt;, ## # DESCRICAO_UG &lt;chr&gt;, GESTAO &lt;chr&gt;, PT &lt;chr&gt;, PT_DESCRICAO &lt;chr&gt;, ## # FONTE_MAE &lt;chr&gt;, DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; # filtros baseados em multiplas colunas df_despesas %&gt;% filter(str_detect(DESCRICAO_UG, &quot;POLICIA&quot;), MES == 1, VALOR_EMPENHADO == 0) ## # A tibble: 2 x 44 ## ANO MES UG DESCRICAO_UG GESTAO PT PT_DESCRICAO FONTE_MAE ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 1 5400… POLICIA CIV… 00001 0618… MANUTENCAO … 0100 ## 2 2017 1 5400… POLICIA CIV… 00001 0618… MANUTENCAO … 0100 ## # ... with 36 more variables: DESCRICAO_FONTE_MAE &lt;chr&gt;, FONTE &lt;chr&gt;, ## # DESCRICAO_FONTE &lt;chr&gt;, PI &lt;chr&gt;, CODIGO_FAVORECIDO &lt;chr&gt;, ## # NOME_FAVORECIDO &lt;chr&gt;, NATUREZA1 &lt;int&gt;, DESCRICAO_NATUREZA1 &lt;chr&gt;, ## # NATUREZA2 &lt;int&gt;, DESCRICAO_NATUREZA2 &lt;chr&gt;, NATUREZA3 &lt;int&gt;, ## # DESCRICAO_NATUREZA3 &lt;chr&gt;, NATUREZA4 &lt;int&gt;, DESCRICAO_NATUREZA4 &lt;chr&gt;, ## # NATUREZA5 &lt;int&gt;, DESCRICAO_NATUREZA5 &lt;chr&gt;, NATUREZA6 &lt;int&gt;, ## # DESCRICAO_NATUREZA6 &lt;chr&gt;, NATUREZA &lt;int&gt;, DESCRICAO_NATUREZA &lt;chr&gt;, ## # DATA_REGISTRO &lt;date&gt;, PROJETO_ATIVIDADE_ID &lt;dbl&gt;, PROGRAMA_ID &lt;int&gt;, ## # SUB_FUNCAO_ID &lt;int&gt;, PT_FUNCAO_ID &lt;int&gt;, FONTE_MAE_ID &lt;int&gt;, ## # FONTE_ID &lt;dbl&gt;, FL_DIARIA &lt;int&gt;, FL_FAVORECIDO &lt;int&gt;, SUBTITULO &lt;int&gt;, ## # DESCRICAO_SUBTITULO &lt;chr&gt;, ORGAO &lt;chr&gt;, ORGAO_DESCRICAO &lt;chr&gt;, ## # VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, VALOR_PAGO &lt;dbl&gt; Referências: Documentação da função filter() 1.4.3 mutate() mutate() serve para criar novas colunas que são funções de colunas já existentes no dataframe # criar dataset menor para servir de exemplo df_menor &lt;- df_despesas %&gt;% select(DESCRICAO_UG, CODIGO_FAVORECIDO, NOME_FAVORECIDO, DATA_REGISTRO, VALOR_EMPENHADO, VALOR_LIQUIDADO, VALOR_PAGO) %&gt;% head(10) df_menor ## # A tibble: 10 x 7 ## DESCRICAO_UG CODIGO_FAVORECI… NOME_FAVORECIDO DATA_REGISTRO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 2 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 3 SEC DE ESTA… 07244008000304 EYES NWEHERE S… 2017-12-22 ## 4 SEC DE ESTA… 24472748000155 EQUILIBRIO SER… 2017-07-10 ## 5 SEC DE ESTA… 06536764412 SAMUEL JACKSON… 2017-06-23 ## 6 POLICIA MIL… 04834392000145 BRASCAR LOCADO… 2017-10-18 ## 7 SEC DE ESTA… 08445586483 JOSE RODRIGO D… 2017-05-16 ## 8 DEPARTAM DE… 35034750449 JOSE CICERO GO… 2017-07-14 ## 9 SEC DE ESTA… 12498937000118 SOPROBEM SERV … 2017-07-11 ## 10 SEC DE ESTA… 02558157001215 TELEFONICA DO … 2017-07-14 ## # ... with 3 more variables: VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, ## # VALOR_PAGO &lt;dbl&gt; # tarefa: criar nova coluna com o dia do registro df_menor %&gt;% mutate(DIA_REGISTRO = lubridate::day(DATA_REGISTRO)) %&gt;% select(DATA_REGISTRO, DIA_REGISTRO) ## # A tibble: 10 x 2 ## DATA_REGISTRO DIA_REGISTRO ## &lt;date&gt; &lt;int&gt; ## 1 2017-11-30 30 ## 2 2017-11-30 30 ## 3 2017-12-22 22 ## 4 2017-07-10 10 ## 5 2017-06-23 23 ## 6 2017-10-18 18 ## 7 2017-05-16 16 ## 8 2017-07-14 14 ## 9 2017-07-11 11 ## 10 2017-07-14 14 # tarefa: criar varias colunas de resultados de equações simples df_menor %&gt;% mutate(VALOR_PAGO_RAIZ_2 = sqrt(VALOR_PAGO), valor_pago_quadrado = VALOR_PAGO^2, valor_pago_dobro = VALOR_PAGO*2, valor_pago_arredondado = round(VALOR_PAGO), valor_pago_soma = VALOR_PAGO + VALOR_EMPENHADO + VALOR_LIQUIDADO) %&gt;% select(contains(&quot;valor_pago&quot;, ignore.case = TRUE)) ## # A tibble: 10 x 6 ## VALOR_PAGO VALOR_PAGO_RAIZ… valor_pago_quad… valor_pago_dobro ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 25557. 160. 653166894. 51114. ## 2 36652. 191. 1343358841. 73304. ## 3 78990. 281. 6239341110. 157979 ## 4 0 0 0 0 ## 5 0 0 0 0 ## 6 0 0 0 0 ## 7 133. 11.5 17777. 267. ## 8 300 17.3 90000 600 ## 9 83773. 289. 7017970819. 167547. ## 10 949. 30.8 901436. 1899. ## # ... with 2 more variables: valor_pago_arredondado &lt;dbl&gt;, ## # valor_pago_soma &lt;dbl&gt; # tarefa: extrair primeiro nome da coluna NOME_FAVORECIDO df_menor %&gt;% mutate(primeiro_nome = stringr::word(NOME_FAVORECIDO, 1)) %&gt;% select(NOME_FAVORECIDO, primeiro_nome) ## # A tibble: 10 x 2 ## NOME_FAVORECIDO primeiro_nome ## &lt;chr&gt; &lt;chr&gt; ## 1 FOLHA PAGTO.PESSOAL FOLHA ## 2 FOLHA PAGTO.PESSOAL FOLHA ## 3 EYES NWEHERE SIST INTELIGENTES DE IMAGEM LTDA EYES ## 4 EQUILIBRIO SERVICOS LTDA - ROTACAR LOCADORA EQUILIBRIO ## 5 SAMUEL JACKSON OLIVEIRA DE LIMA SAMUEL ## 6 BRASCAR LOCADORA LTDA BRASCAR ## 7 JOSE RODRIGO DOS SANTOS NUNES JOSE ## 8 JOSE CICERO GOMES DA SILVA JOSE ## 9 SOPROBEM SERV PROM E BEM ESTAR COMUNITARIO SOPROBEM ## 10 TELEFONICA DO BRASIL S.A. TELEFONICA # tarefa: converter coluna NOME_FAVORECIDO para minusculo, # com exceção da primeira letra de cada palavra df_menor %&gt;% mutate(NOME_FAVORECIDO = stringr::str_to_title(NOME_FAVORECIDO)) %&gt;% select(NOME_FAVORECIDO) ## # A tibble: 10 x 1 ## NOME_FAVORECIDO ## &lt;chr&gt; ## 1 Folha Pagto.pessoal ## 2 Folha Pagto.pessoal ## 3 Eyes Nwehere Sist Inteligentes De Imagem Ltda ## 4 Equilibrio Servicos Ltda - Rotacar Locadora ## 5 Samuel Jackson Oliveira De Lima ## 6 Brascar Locadora Ltda ## 7 Jose Rodrigo Dos Santos Nunes ## 8 Jose Cicero Gomes Da Silva ## 9 Soprobem Serv Prom E Bem Estar Comunitario ## 10 Telefonica Do Brasil S.a. Referências: Documentação da função mutate() 1.4.4 arrange() arrange() muda a posição das linhas do dataframe baseado em uma ou mais colunas, em ordem crescente ou decrescente É como o classificar do Excel. # classificar tabela de acordo com a ordem crescente da coluna NOME_FAVORECIDO df_menor %&gt;% arrange(NOME_FAVORECIDO) ## # A tibble: 10 x 7 ## DESCRICAO_UG CODIGO_FAVORECI… NOME_FAVORECIDO DATA_REGISTRO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 POLICIA MIL… 04834392000145 BRASCAR LOCADO… 2017-10-18 ## 2 SEC DE ESTA… 24472748000155 EQUILIBRIO SER… 2017-07-10 ## 3 SEC DE ESTA… 07244008000304 EYES NWEHERE S… 2017-12-22 ## 4 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 5 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 6 DEPARTAM DE… 35034750449 JOSE CICERO GO… 2017-07-14 ## 7 SEC DE ESTA… 08445586483 JOSE RODRIGO D… 2017-05-16 ## 8 SEC DE ESTA… 06536764412 SAMUEL JACKSON… 2017-06-23 ## 9 SEC DE ESTA… 12498937000118 SOPROBEM SERV … 2017-07-11 ## 10 SEC DE ESTA… 02558157001215 TELEFONICA DO … 2017-07-14 ## # ... with 3 more variables: VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, ## # VALOR_PAGO &lt;dbl&gt; # fazer o mesmo que acima, mas usando ordem decrescente df_menor %&gt;% arrange(desc(NOME_FAVORECIDO)) ## # A tibble: 10 x 7 ## DESCRICAO_UG CODIGO_FAVORECI… NOME_FAVORECIDO DATA_REGISTRO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 SEC DE ESTA… 02558157001215 TELEFONICA DO … 2017-07-14 ## 2 SEC DE ESTA… 12498937000118 SOPROBEM SERV … 2017-07-11 ## 3 SEC DE ESTA… 06536764412 SAMUEL JACKSON… 2017-06-23 ## 4 SEC DE ESTA… 08445586483 JOSE RODRIGO D… 2017-05-16 ## 5 DEPARTAM DE… 35034750449 JOSE CICERO GO… 2017-07-14 ## 6 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 7 UNIVERS EST… PF0000001 FOLHA PAGTO.PE… 2017-11-30 ## 8 SEC DE ESTA… 07244008000304 EYES NWEHERE S… 2017-12-22 ## 9 SEC DE ESTA… 24472748000155 EQUILIBRIO SER… 2017-07-10 ## 10 POLICIA MIL… 04834392000145 BRASCAR LOCADO… 2017-10-18 ## # ... with 3 more variables: VALOR_EMPENHADO &lt;dbl&gt;, VALOR_LIQUIDADO &lt;dbl&gt;, ## # VALOR_PAGO &lt;dbl&gt; # mostrar datas onde houve os maiores valores de despesa com folha de pagamento df_despesas %&gt;% filter(NOME_FAVORECIDO == &quot;FOLHA PAGTO.PESSOAL&quot;) %&gt;% select(DATA_REGISTRO, VALOR_PAGO) %&gt;% arrange(desc(VALOR_PAGO)) ## # A tibble: 10,285 x 2 ## DATA_REGISTRO VALOR_PAGO ## &lt;date&gt; &lt;dbl&gt; ## 1 2017-06-30 36199947. ## 2 2017-07-31 36197178. ## 3 2017-05-31 35974835. ## 4 2017-01-31 35902479. ## 5 2017-09-30 35538295. ## 6 2017-12-15 35507190. ## 7 2017-08-30 35505462. ## 8 2017-02-28 35393811. ## 9 2017-10-31 35249901. ## 10 2017-03-31 35149377. ## # ... with 10,275 more rows # classificar dados pelo NOME_FAVORECIDO, mostrando os maiores valores pagos para cada df_despesas %&gt;% select(DATA_REGISTRO, NOME_FAVORECIDO, VALOR_PAGO) %&gt;% arrange(NOME_FAVORECIDO, desc(VALOR_PAGO)) ## # A tibble: 192,638 x 3 ## DATA_REGISTRO NOME_FAVORECIDO VALOR_PAGO ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2017-07-26 13 SUPERINTENDENCIA REGIONAL DE POL. ROD. 766. ## 2 2017-09-19 13 SUPERINTENDENCIA REGIONAL DE POL. ROD. 156. ## 3 2017-07-26 13 SUPERINTENDENCIA REGIONAL DE POL. ROD. 0 ## 4 2017-10-20 1 REGISTRO G. DE IMOVEIS E HIPOTECA MACEIO. 8849. ## 5 2017-09-29 1 REGISTRO G. DE IMOVEIS E HIPOTECA MACEIO. 0 ## 6 2017-10-05 1 REGISTRO G. DE IMOVEIS E HIPOTECA MACEIO. 0 ## 7 2017-10-30 3D INFORMATIC SERVICOS LTDA 0 ## 8 2017-10-30 3D INFORMATIC SERVICOS LTDA 0 ## 9 2017-04-25 3D INFORMATIC SERVICOS LTDA 0 ## 10 2017-04-25 3D INFORMATIC SERVICOS LTDA 0 ## # ... with 192,628 more rows Referências: Documentação da função arrange() 1.4.5 group_by() e summarise() O combo group_by() e summarise() é excelente para agregar e resumir dados. Com group_by(), as funções aplicadas com summarise() ou até mesmo com mutate() ou filter() são aplicadas não em todo o dataset mas sim em cada grupo da variável especificada na função group_by # calcular o valor medio pago agrupado por DESCRICAO_UG df_despesas %&gt;% group_by(DESCRICAO_UG) %&gt;% summarise(VALOR_PAGO_MEDIO = mean(VALOR_PAGO)) ## # A tibble: 80 x 2 ## DESCRICAO_UG VALOR_PAGO_MEDIO ## &lt;chr&gt; &lt;dbl&gt; ## 1 AG DE MODERNIZACAO DA GESTAO DE PROCESSOS 18098. ## 2 AGENC DE DEFESA E INSPECAO AGROPECUARIA DE AL 5041. ## 3 AGENCIA DE FOMENTO DE ALAGOAS 2382. ## 4 AGENCIA REGULADORA DOS SERV PUB DO EST DE AL 4068. ## 5 ALAGOAS PREVIDENCIA 18652. ## 6 ASSEMBLEIA LEGISLATIVA ESTADUAL 252891. ## 7 CIA DE ADMINIST DE REC HUMANOS E PATRIMONIAIS 24303. ## 8 CONTROLADORIA GERAL DO ESTADO 6372. ## 9 COORDENADORIA ESTADUAL DE DEFESA CIVIL CEDEC 17926. ## 10 CORPO DE BOMBEIROS MILITAR DO ESTADO DE AL 64719. ## # ... with 70 more rows # Calcular a soma do valor pago, a quantidade de registros e... # a quantidade de favorecidos disintos para cada UG. # classificar pela qtd de favorecidos distintos em ordem decrescente df_despesas %&gt;% group_by(DESCRICAO_UG) %&gt;% summarise(VALOR_PAGO_TOTAL = sum(VALOR_PAGO), QTD_OBSERVACOES = n(), QTD_FAVORECIDOS_DIFERENTES = n_distinct(CODIGO_FAVORECIDO)) %&gt;% arrange(desc(QTD_FAVORECIDOS_DIFERENTES)) ## # A tibble: 80 x 4 ## DESCRICAO_UG VALOR_PAGO_TOTAL QTD_OBSERVACOES QTD_FAVORECIDOS_D… ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 SEC DE ESTADO DA S… 88281789. 11586 1850 ## 2 SECRETARIA DE ESTA… 688386057. 21800 1530 ## 3 UNIVERS ESTADUAL D… 218302840. 23790 1377 ## 4 FUNDO ESTADUAL DE … 250232390. 5014 738 ## 5 SECRETARIA DE ESTA… 656421639. 5734 681 ## 6 POLICIA CIVIL DO E… 263251822. 9275 579 ## 7 INSTITUTO DO MEIO … 13245505. 7800 444 ## 8 FUN DE AMPARO A PE… 20997494. 2745 441 ## 9 TRIBUNAL DE JUSTICA 446800776. 2843 432 ## 10 POLICIA MILITAR DO… 641422440. 3105 392 ## # ... with 70 more rows # calcular a soma de todas as variáveis que começam com valor por ano e mês... # apenas para o UG &quot;ALAGOAS PREVIDENCIA&quot; df_despesas %&gt;% filter(DESCRICAO_UG == &quot;ALAGOAS PREVIDENCIA&quot;) %&gt;% group_by(ANO, MES) %&gt;% summarise_at(vars(contains(&quot;VALOR_&quot;)), sum) ## # A tibble: 11 x 5 ## # Groups: ANO [?] ## ANO MES VALOR_EMPENHADO VALOR_LIQUIDADO VALOR_PAGO ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2017 2 1426284. 1303068. 1303068. ## 2 2017 3 1504915. 1107573. 865426. ## 3 2017 4 1475190. 1619974. 1839362. ## 4 2017 5 1349917. 1511101. 1323909. ## 5 2017 6 1375101. 1411114. 1411114. ## 6 2017 7 1729151. 1739711. 1713611. ## 7 2017 8 2039230. 1041208. 1251158. ## 8 2017 9 1072202. 1749638. 1739718. ## 9 2017 10 1139471. 1349006. 1354523. ## 10 2017 11 1853057. 1214717. 1232741. ## 11 2017 12 18273418. 19190829. 16983302. # count() é uma alternativa a group_by() + summarise(n()) df_despesas %&gt;% count(CODIGO_FAVORECIDO, NOME_FAVORECIDO) %&gt;% filter(n &gt; 100) %&gt;% arrange(desc(n)) ## # A tibble: 125 x 3 ## CODIGO_FAVORECIDO NOME_FAVORECIDO n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 PF0000001 FOLHA PAGTO.PESSOAL 10285 ## 2 29979036000221 INSS - INSTITUTO NACIONAL DO SEGURO SOCIAL 3553 ## 3 13353495000184 PROPAG TURISMO LTDA 2452 ## 4 12272084000100 COMPANHIA ENERGETICA DE ALAGOAS - CEAL 1304 ## 5 24472748000155 EQUILIBRIO SERVICOS LTDA - ROTACAR LOCADORA 1292 ## 6 PF0000002 DIVIDA/AJUS. FISCAL 991 ## 7 33000118001302 TELEMAR NORTE LESTE S.A 922 ## 8 PF0000006 INATIVOS E PENSIONI 889 ## 9 12272084000100 CIA EDE ELETRICA DE ALAGOAS 883 ## 10 05423963000111 OI MOVEL S/A 848 ## # ... with 115 more rows Referências: Documentação da função group_by() Documentação da função summarise() 1.5 Juntando duas tabelas em uma Em muitas situações durante uma análise de dados, é comum trabalhar com mais de uma tabela, sendo assim necessário usar ferramentas para as combinar em uma tabela só. Para quem vem do Excel, é algo similar ao que faz o PROCV ou VLOOKUP. O dplyr oferece várias funções para realizar a junção de duas tabelas, que são a familía x_join(). Todas seguem a mesma sintaxe: x_join(x, y, by), onde x e y são os dois dataframes a serem juntados e by é um vetor de caracteres especificando a coluna que será usada como chave. Abaixo, criamos dois datafremes simples para demonstrar o uso de duas operações de juntar tabelas: left_join(), inner_join() e full_join(). Todas as funções possuem a sintaxe: vendedor &lt;- tibble( id = c(&quot;A12&quot;, &quot;A13&quot;, &quot;A14&quot;, &quot;A15&quot;), regiao = c(&quot;Sul&quot;, &quot;Sudeste&quot;, &quot;Oeste&quot;, &quot;Norte&quot;), experiencia = c(5, 2, 12, 8) ) vendas = tibble( id = c(&quot;A13&quot;, &quot;A14&quot;, &quot;A12&quot;, &quot;A11&quot;), vendas = c(1200, 2500, 350, 1000) ) vendedor ## # A tibble: 4 x 3 ## id regiao experiencia ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 A12 Sul 5 ## 2 A13 Sudeste 2 ## 3 A14 Oeste 12 ## 4 A15 Norte 8 vendas ## # A tibble: 4 x 2 ## id vendas ## &lt;chr&gt; &lt;dbl&gt; ## 1 A13 1200 ## 2 A14 2500 ## 3 A12 350 ## 4 A11 1000 left_join(x, y): retorna todas as observações em x, independentemente se existem correspondentes (de acordo com as especificações em by) ou não. left_join(vendedor, vendas, by = &quot;id&quot;) ## # A tibble: 4 x 4 ## id regiao experiencia vendas ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A12 Sul 5 350 ## 2 A13 Sudeste 2 1200 ## 3 A14 Oeste 12 2500 ## 4 A15 Norte 8 NA inner_join(x, y): retornar apenas observações que correspondem tanto em x como em y. Note como o vendedor A15 não consta no dataframe final, pois ele não está presente no dataframe y: inner_join(vendedor, vendas, by = &quot;id&quot;) ## # A tibble: 3 x 4 ## id regiao experiencia vendas ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A12 Sul 5 350 ## 2 A13 Sudeste 2 1200 ## 3 A14 Oeste 12 2500 full_join(x, y) é mais completo e retorna todas as observações presentes em x e y: full_join(vendedor, vendas, by = &quot;id&quot;) ## # A tibble: 5 x 4 ## id regiao experiencia vendas ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A12 Sul 5 350 ## 2 A13 Sudeste 2 1200 ## 3 A14 Oeste 12 2500 ## 4 A15 Norte 8 NA ## 5 A11 &lt;NA&gt; NA 1000 Referências: Tutorial sobre funções para trabalhar com mais de uma tabela Documentação sobre funções da família join 1.6 tidyr tidyr é outro pacote do tidyverse focado no manuseio de dados. Seu foco é transformar datasets no formato tidy, que facilita seu uso em pacotes como dplyr e ggplot2. Confira o dataset abaixo (leia a documentação em ?economics para saber o significado das variáveis): data(&quot;economics&quot;) # ?economics head(economics) ## # A tibble: 6 x 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1967-07-01 507. 198712 12.5 4.5 2944 ## 2 1967-08-01 510. 198911 12.5 4.7 2945 ## 3 1967-09-01 516. 199113 11.7 4.6 2958 ## 4 1967-10-01 513. 199311 12.5 4.9 3143 ## 5 1967-11-01 518. 199498 12.5 4.7 3066 ## 6 1967-12-01 526. 199657 12.1 4.8 3018 Suponha que você deseja saber o valor médio dos indicadores pce, pop, psavert, uempmed, e unemploy para cada ano. Usando o que já aprendemos com o dplyr, podemos fazer assim: economics %&gt;% # criar nova variavel com o ano da data mutate(ano = lubridate::year(date)) %&gt;% # agrupar os dados por ano group_by(ano) %&gt;% # calcular as medias de todas as variaveis summarise( pce = mean(pce), pop = mean(pop), psavert = mean(psavert), uempmed = mean(uempmed), unemploy = mean(unemploy) ) %&gt;% head() ## # A tibble: 6 x 6 ## ano pce pop psavert uempmed unemploy ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967 515. 199200. 12.3 4.7 3012. ## 2 1968 557. 200664. 11.2 4.5 2797. ## 3 1969 604. 202649. 10.7 4.44 2830. ## 4 1970 648. 204982. 12.6 4.98 4127. ## 5 1971 701 207589. 13.3 6.28 5022. ## 6 1972 769. 209838. 12.1 6.11 4876. E se tivéssemos centenas de colunas? E se quisermos plotar todas essas variáveis em um gráfico de linha? Isso demandaria muito código manual. Esse é um exemplo onde transformar os dados em um formato tidy é benéfico. Para isso, usamos a função gather, que precisa de três argumentos: O conjunto de colunas que serão transformadas de colunas para linhas; O nome da variável (coluna) cujos valores serão as colunas transformadas acima; O nome da variável cujos valores serão os valores correspondentes das colunas transformadas; Observe o exemplo abaixo: economics %&gt;% gather(indicador, valor, -date) ## # A tibble: 2,870 x 3 ## date indicador valor ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1967-07-01 pce 507. ## 2 1967-08-01 pce 510. ## 3 1967-09-01 pce 516. ## 4 1967-10-01 pce 513. ## 5 1967-11-01 pce 518. ## 6 1967-12-01 pce 526. ## 7 1968-01-01 pce 532. ## 8 1968-02-01 pce 534. ## 9 1968-03-01 pce 545. ## 10 1968-04-01 pce 545. ## # ... with 2,860 more rows Com isso, nós transformamos um dataset de um formato wide (menos linhas e mais colunas) em um formato long (mais linhas e menos colunas), que está no formato ideal para ser usado com a suíte de pacotes tidyverse, entre eles o ggplot2. Em algumas situações, porém, será necessário fazer o contrário: transformar o dataset de long para wide. Para isso, usa-se a função spread(): data(&quot;economics_long&quot;) head(economics_long) ## # A tibble: 6 x 4 ## # Groups: variable [1] ## date variable value value01 ## &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 pce 507. 0 ## 2 1967-08-01 pce 510. 0.000266 ## 3 1967-09-01 pce 516. 0.000764 ## 4 1967-10-01 pce 513. 0.000472 ## 5 1967-11-01 pce 518. 0.000918 ## 6 1967-12-01 pce 526. 0.00158 economics_long %&gt;% select(-value01) %&gt;% spread(variable, value, fill = NA) ## # A tibble: 574 x 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 507. 198712 12.5 4.5 2944 ## 2 1967-08-01 510. 198911 12.5 4.7 2945 ## 3 1967-09-01 516. 199113 11.7 4.6 2958 ## 4 1967-10-01 513. 199311 12.5 4.9 3143 ## 5 1967-11-01 518. 199498 12.5 4.7 3066 ## 6 1967-12-01 526. 199657 12.1 4.8 3018 ## 7 1968-01-01 532. 199808 11.7 5.1 2878 ## 8 1968-02-01 534. 199920 12.2 4.5 3001 ## 9 1968-03-01 545. 200056 11.6 4.1 2877 ## 10 1968-04-01 545. 200208 12.2 4.6 2709 ## # ... with 564 more rows Referências: Site oficial do pacote tidyr Capítulo “Limpando os dados” do livro Ciência de Dados com R Capítulo “Tidy data” do livro R for Data Science Cheatsheet do pacote tidyr Artigo científico Tidy data 1.7 Exercícios Carregue os pacotes tidyverse e janitor. Baixe o dataset de Super Heróis do Kaggle. Descompacte o arquivo e importe os dois arquivos para o R: salve o arquivo super_hero_powers.csv no objeto hero_powers e o arquivo heroes_information.csv no objeto hero_info. Use também na função read_csv o argumento na = c(&quot;&quot;, &quot;-&quot;, &quot;NA&quot;)) para que linhas com traço ou vazias sejam convertidas para NA. Observe as colunas presentes nos datasets usando a função glimpse. Use a função janitor::clean_names() para limpar os nomes das colunas. No caso de hero_info, remova a primeira coluna. Em hero_powers, converta todas as colunas com exceção da primeira para o tipo logical. Em hero_info, na coluna publisher, observe quantas editoras diferentes existem no dataset. Substitua Marvel Comics por Marvel, DC Comics por DC e todas as outras editoras pelo termo “Outros”. Dica: uma das possíveis maneiras de fazer isso é usando uma combinação das funções dplyr::mutate() e dplyr::case_when(). Em hero_info, quais raças (coluna race) são exclusivas de cada editora? Em hero_info, quais cores de olhos (coluna eye_color) são mais comuns para cada sexo (coluna gender)? Filtre o top 3 para cadda sexo. Em hero_powers, calcule o percentual de heróis que possui cada habilidade descrita nas colunas (Dica: é possível calcular a soma ou percentual de um vetor lógico, pois TRUE equivale a 1 e FALSE a 0). Use a função dplyr::summarise_if para aplicar a função em todas as colunas cuja classe é logical. Repita o item anterior, usando uma abordagem mais tidy: converta o formato do dataframe hero_powers para o formato long. Ele passará a possuir apenas 3 colunas: hero_names, poder e possui_poder usando a função tidyr::gather(). Então, calcule a média da coluna possui_poder agrupado pela coluna poder. Junte os dois dataframes em um só, chamado hero. A função a ser usada é inner_join(). Pense bem em qual será a ordem dos dataframes nos argumentos da função e qual será a chave usada no argumento by para unir as duas tabelas. No dataframe hero, calcule o percentual de herois de cada editora que são telepatas. No dataframe hero, selecione as colunas name, publisher, flight e weight, filtre os heróis que podem voar e retorne os 10 de maior peso. Salve o dataframe chamado hero no arquivo herois_completo.csv usando a função readr::write_csv(). "],
["introducao-ao-ggplot2.html", "Módulo 2 Introdução ao ggplot2 2.1 Dataset do módulo 2.2 ggplot2: filosofia do pacote e do Grammar of Graphics 2.3 geoms 2.4 aes 2.5 A anatomia da função ggplot() 2.6 Segmentação de um gráfico em grupos com os facets 2.7 Salvando gráficos do ggplot2 2.8 Juntando diferentes gráficos em um só 2.9 Gráficos no R além de ggplot2 2.10 Exercícios", " Módulo 2 Introdução ao ggplot2 Neste módulo, usaremos os seguintes pacotes: library(tidyverse) # vamos precisar do pacote janitor para limpar os nomes das colunas library(janitor) # o pacote readxl será usado para importar a planilha excel, visto que o # readr não oferece suporte para arquivos xlsx library(readxl) # metadados gerais de países library(countrycode) # combinar varios graficos do ggplot2 em um so library(patchwork) # devtools::install_github(&quot;thomasp85/patchwork&quot;) # chequem se a versao dos seus pacotes é a mesma das minhas sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Linux Mint 18.2 ## ## Matrix products: default ## BLAS: /usr/lib/openblas-base/libblas.so.3 ## LAPACK: /usr/lib/libopenblasp-r0.2.18.so ## ## locale: ## [1] LC_CTYPE=pt_BR.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=pt_BR.UTF-8 LC_COLLATE=pt_BR.UTF-8 ## [5] LC_MONETARY=pt_BR.UTF-8 LC_MESSAGES=pt_BR.UTF-8 ## [7] LC_PAPER=pt_BR.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=pt_BR.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] patchwork_0.0.1 countrycode_1.00.0 readxl_1.1.0 ## [4] janitor_1.1.1 bindrcpp_0.2.2 forcats_0.3.0 ## [7] stringr_1.3.1 dplyr_0.7.6 purrr_0.2.5 ## [10] readr_1.1.1 tidyr_0.8.1 tibble_1.4.2 ## [13] ggplot2_3.0.0.9000 tidyverse_1.2.1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_0.12.18 lubridate_1.7.4 lattice_0.20-35 ## [4] utf8_1.1.4 assertthat_0.2.0 rprojroot_1.3-2 ## [7] digest_0.6.15 psych_1.8.4 mime_0.5 ## [10] R6_2.2.2 cellranger_1.1.0 plyr_1.8.4 ## [13] backports_1.1.2 evaluate_0.10.1 httr_1.3.1 ## [16] pillar_1.3.0 rlang_0.2.1 lazyeval_0.2.1 ## [19] rstudioapi_0.7 data.table_1.11.4 rmarkdown_1.10 ## [22] foreign_0.8-70 htmlwidgets_1.2 munsell_0.5.0 ## [25] shiny_1.0.5 broom_0.4.5 compiler_3.4.4 ## [28] httpuv_1.4.4.1 modelr_0.1.2 xfun_0.3 ## [31] pkgconfig_2.0.1 mnormt_1.5-5 htmltools_0.3.6 ## [34] tidyselect_0.2.4 bookdown_0.7 fansi_0.3.0 ## [37] viridisLite_0.3.0 withr_2.1.2 crayon_1.3.4 ## [40] later_0.7.3 grid_3.4.4 nlme_3.1-137 ## [43] jsonlite_1.5 xtable_1.8-2 gtable_0.2.0 ## [46] magrittr_1.5 scales_1.0.0.9000 cli_1.0.0 ## [49] stringi_1.2.4 reshape2_1.4.3 promises_1.0.1 ## [52] leaflet_1.1.0 xml2_1.2.0 tools_3.4.4 ## [55] Cairo_1.5-9 glue_1.3.0 hms_0.4.2 ## [58] crosstalk_1.0.0 parallel_3.4.4 yaml_2.1.19 ## [61] colorspace_1.3-2 rvest_0.3.2 plotly_4.8.0 ## [64] knitr_1.20 bindr_0.1.1 haven_1.1.2 2.1 Dataset do módulo Para este módulo, usaremos o dataset World Happiness Report, ou o Relatório Mundial da Felicidade, que é uma medição da felicidade publicado pela Rede de Soluções para o Desenvolvimento Sustentável da ONU (SDSN, na sigla em inglês). Leia o artigo na Wikipedia para mais informações. # baixe o arquivo do endereco: download.file(&quot;https://s3.amazonaws.com/happiness-report/2018/WHR2018Chapter2OnlineData.xls&quot;, destfile = &quot;felicidade.xls&quot;) # importar a planilha df_pais &lt;- read_excel(&quot;felicidade.xls&quot;, sheet = 1) # limpar o nome das colunas df_pais &lt;- janitor::clean_names(df_pais) # olhar dados glimpse(df_pais) ## Observations: 1,562 ## Variables: 19 ## $ country &lt;chr&gt; &quot;Afgha... ## $ year &lt;dbl&gt; 2008, ... ## $ life_ladder &lt;dbl&gt; 3.7235... ## $ log_gdp_per_capita &lt;dbl&gt; 7.1686... ## $ social_support &lt;dbl&gt; 0.4506... ## $ healthy_life_expectancy_at_birth &lt;dbl&gt; 49.209... ## $ freedom_to_make_life_choices &lt;dbl&gt; 0.7181... ## $ generosity &lt;dbl&gt; 0.1818... ## $ perceptions_of_corruption &lt;dbl&gt; 0.8816... ## $ positive_affect &lt;dbl&gt; 0.5176... ## $ negative_affect &lt;dbl&gt; 0.2581... ## $ confidence_in_national_government &lt;dbl&gt; 0.6120... ## $ democratic_quality &lt;dbl&gt; -1.929... ## $ delivery_quality &lt;dbl&gt; -1.655... ## $ standard_deviation_of_ladder_by_country_year &lt;dbl&gt; 1.7746... ## $ standard_deviation_mean_of_ladder_by_country_year &lt;dbl&gt; 0.4765... ## $ gini_index_world_bank_estimate &lt;dbl&gt; NA, NA... ## $ gini_index_world_bank_estimate_average_2000_15 &lt;dbl&gt; NA, NA... ## $ gini_of_household_income_reported_in_gallup_by_wp5_year &lt;dbl&gt; NA, 0.... Sentiram falta de uma coluna com o nome? Vamos também importar um dataset que contém o continente de cada país, fornecido pelo pacote countrycode. # consulte a documentação do dataset # ?countrycode::codelist df_continente &lt;- countrycode::codelist %&gt;% # selecionar colunas importantes select(country = cow.name, continent) %&gt;% # filtrar fora os paises sem continentes filter(!is.na(continent)) # criar dataframe com juncao dos dois df &lt;- left_join(df_pais, df_continente, by = &quot;country&quot;) # consertar manualmente os continentes de certos paises df$continent[df$country == &quot;Congo (Brazzaville)&quot;] &lt;- &quot;Africa&quot; df$continent[df$country == &quot;Congo (Kinshasa)&quot;] &lt;- &quot;Africa&quot; df$continent[df$country == &quot;Hong Kong S.A.R. of China&quot;] &lt;- &quot;Asia&quot; df$continent[df$country == &quot;Kosovo&quot;] &lt;- &quot;Europe&quot; df$continent[df$country == &quot;North Cyprus&quot;] &lt;- &quot;Asia&quot; df$continent[df$country == &quot;Palestinian Territories&quot;] &lt;- &quot;Asia&quot; df$continent[df$country == &quot;Serbia&quot;] &lt;- &quot;Europe&quot; df$continent[df$country == &quot;Somaliland region&quot;] &lt;- &quot;Africa&quot; df$continent[df$country == &quot;Taiwan Province of China&quot;] &lt;- &quot;Asia&quot; df$continent[df$country == &quot;United States&quot;] &lt;- &quot;Americas&quot; # transformar coluna de ano para inteiro df$year &lt;- as.integer(df$year) # criar dataset apenas para o ano mais recente df_2017 &lt;- df %&gt;% filter(year == max(year)) 2.2 ggplot2: filosofia do pacote e do Grammar of Graphics O pacote ggplot2 é uma implementação da filosofia Grammar of Graphics, que busca construir e explicar gráficos como uma série de camadas individuais sobrepostas. Apesar de simples, é uma definição muito concisa e que ajuda o usuário do pacote a representar a informação desejada da melhor maneira possível. Cada camada contem elementos visuais como barras, pontos e texto. Elementos visuais são conhecidos como geoms (de objetos geométricos). Um geom possui propriedades estéticas que determinam sua aparência e sua posição no gráfico (ex.: queremos plotar barras vermelhas ou verdes? Os pontos do gráfico serão representados por círculos ou quadrados?). Tais estéticas (aesthetics ou aes no ggplot2) controlam a aparência dos elementos gráficos, como tamanho, cor, estilo, localização e transparência. Portanto, o código abaixo representa o “esqueleto” do código usado para produzir um gráfico no ggplot2: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) 2.3 geoms Existe uma variedade de funções que controlam que tipo de objeto geométrico será plotado no gráfico. A lista completa pode ser vista na documentação online do ggplot2. As mais comuns são: 2.3.1 geom_bar() e geom_col() Gráfico de barra, feito para visualizar uma variável numérica ou propriedade estatística (ex.: média) entre diferentes grupos categóricos; # Tarefa: Criar um gráfico mostrando a média do score de felicidade por continente df_2017 %&gt;% group_by(continent) %&gt;% summarise(life_ladder = mean(life_ladder)) %&gt;% ggplot(aes(x = continent, y = life_ladder)) + geom_col() 2.3.2 geom_point() Gráficos de pontos, também conhecidos como gráfico de dispersão; df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() ## Warning: Removed 7 rows containing missing values (geom_point). 2.3.3 geom_line() Gráfico de linha, especialmente útil para séries temporais; df %&gt;% filter(country == &quot;Brazil&quot;, year &gt;= 2007) %&gt;% ggplot(aes(x = year, y = life_ladder)) + geom_line() 2.3.4 geom_histogram() Cria uma camada com um histograma df_2017 %&gt;% ggplot(aes(x = life_ladder)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 2.3.5 geom_text() Cria uma camada com texto. df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + geom_text(aes(label = country)) ## Warning: Removed 7 rows containing missing values (geom_point). ## Warning: Removed 7 rows containing missing values (geom_text). 2.3.6 geom_hline() and geom_vline() Cria uma camada com uma linha horizontal ou vertical, respectivamente. df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + geom_vline(aes(xintercept = mean(df_2017$log_gdp_per_capita, na.rm = TRUE))) + geom_hline(aes(yintercept = mean(df_2017$healthy_life_expectancy_at_birth, na.rm = TRUE))) ## Warning: Removed 7 rows containing missing values (geom_point). Essas e outras formas geométricas serão detalhadas no próximo módulo. Referências: Lista completa com todas as geoms do ggplot2 2.4 aes Uma aesthetic é uma propriedade visual dos objetos no gráfico e incluem atributos como posição (eixos x e y), tamanho, formato ou cor dos objetos. Portanto, as aesthetics modificam a aparência de um elemento dentro de um geom ou camada. É possível especificar aesthetics para o gráfico como um todo (como as variáveis a serem mapeadas nos eixos) e tais instruções serão aplicadas a todos os geoms adicionados posteriormente. Contudo, também é possível especificar aesthetics para geoms individualmente, que sobrescreverão as definidas para o gráfico. Vamos ver então como definir as aesthetics. Primeiramente, elas podem ser definidas para um valor em específico, como cor verde, ou pode ser declarada em função de uma variável (como colorir os indíviduos do gráfico de pontos anterior de acordo com o continente). Para definir uma aesthetic como um valor específico, não é necessário a definir dentro da função aes(). É possível definir tanto as aesthetics específicas ou em função de uma variável na definição do gráfico ou apenas da geom, mas caso se deseja definir um valor específico, isso só pode ser feito dentro do geom que se deseja modificar. Confuso? Vejamos como exemplos. Neste primeiro exemplo, mudamos a propriedade color dos pontos para um valor específico: marrom. df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point(color = &quot;brown&quot;) ## Warning: Removed 7 rows containing missing values (geom_point). Caso o objetivo seja definir (mapear) a aesthetic de cor para o continente do país, é necessário definir dentro da função aes(): df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point(aes(color = continent)) ## Warning: Removed 7 rows containing missing values (geom_point). Conforme comentado, é possível definir o mapeamento do atributo dentro da função geral do gráfico: df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth, color = continent)) + geom_point() ## Warning: Removed 7 rows containing missing values (geom_point). Contudo, observe o que acontece nas duas situações quando adicionamos uma geom a mais, a geom_smooth(): df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point(aes(color = continent)) + # adicionar curva de tendencia, sem margem de erro, usando o metodo # de regressao linear geom_smooth(method = &quot;lm&quot;, se = FALSE) df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth, color = continent)) + geom_point() + # adicionar curva de tendencia, sem margem de erro, usando o metodo # de regressao linear geom_smooth(method = &quot;lm&quot;, se = FALSE) No primeiro gráfico, a reta manteve-se a mesma para todos os dados. No segundo, foi uma reta para cada continente, pois geom_smooth() herdou a definição do atributo de cor criada na função ggplot(). Também é possível definir mais de uma geom ao mesmo tempo: # glimpse(df_2017) df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + # mapear cor ao continente geom_point(aes(color = continent, # tamanho a confiança no governo size = confidence_in_national_government), # opacidade a um valor absoluto alpha = 0.7) ## Warning: Removed 19 rows containing missing values (geom_point). Referências: Documentação da função aes() Tutorial oficial sobre aesthetics 2.5 A anatomia da função ggplot() O primeiro passo para criar um gráfico no ggplot2 é criar um objeto que especifica o gráfico. Você pode, nesta etapa, definir as aesthetics que serão aplicadas a todos os geoms (camadas) dentro do gráfico. Uma versão geral dessa descrição tem a seguinte aparência: meu_grafico &lt;- ggplot(meus_dados, aes(x = variavel1, y = variavel2)) Neste examplo, criamos um novo objeto chamado meu_grafico, definimos na função ggplot() para usar o dataframe meu_grafico e especificamos que a variável (que pertence ao dataframe meu_grafico) variavel1 será plotada no eixo horizontal e a variável variavel2 no eixo vertical. Até o momento, o objeto meu_grafico não possui nenhum elemento gráfico. Se você tentar o visualizar, seja digitando seu próprio nome ou com a função print(meu_grafico), você verá apenas um pano de fundo. É necessário então acrescentar uma camada que contenha um geom. Para adicionar uma camada ao gráfico, basta usar o símbolo de adição +: # adicionar uma camada de grafico de pontos ao objeto meu_grafico + geom_point() Referências: Documentação da função ggplot() 2.6 Segmentação de um gráfico em grupos com os facets facets são um excelente recurso do ggplot2 que permitem segmentar um gráfico em subgráficos de acordo com uma variável categórica. Existem duas maneiras de definir facets no ggplot2: facet_wrap(), ideal para apenas uma variável, e facet_grid() ideal para uma combinação de duas variáveis. Já vimos como acrescentar a informação do continente em um gráfico de pontos mudando o atributo color. Uma alternativa é criar um subgráfico para cada continente por meio de facets. O primeiro argumento da função facet_wrap() é uma fórmula, um tipo de sintaxe especial do R, em que se deve escrever o acento til (~) seguido do nome da variável que servirá para segmentar o gráfico. df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + facet_wrap(~ continent) ## Warning: Removed 7 rows containing missing values (geom_point). Caso se deseja utilizar mais de uma variável para criar os facets, usa-se a função facet_grid(): df %&gt;% # filtrar os anos de 2015 a 2017 filter(between(year, 2015, 2017)) %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + facet_grid(continent ~ year) ## Warning: Removed 14 rows containing missing values (geom_point). Vamos salvar o dataframe para ser usado nos próximos módulos: # vamos salvar em um formato específico do R df_2017 %&gt;% # remover colunas com muitos NAs ou que nao vamos usar select(-c(democratic_quality, delivery_quality, gini_index_world_bank_estimate, gini_index_world_bank_estimate_average_2000_15, confidence_in_national_government, generosity, standard_deviation_of_ladder_by_country_year, standard_deviation_mean_of_ladder_by_country_year)) %&gt;% # encurtar nome de coluna rename(gini = gini_of_household_income_reported_in_gallup_by_wp5_year) %&gt;% # salvar no formato rds, proprio do R e que mantem a integridade # dos dados write_rds(&quot;dados_felicidade_2017.rds&quot;) Referências: Documentação de facet_grid() Documentação de facet_wrap() Mais funções para customizar facets 2.7 Salvando gráficos do ggplot2 Para salvar um gráfico do ggplot2 em um arquivo em seu computador, basta usar a função ggsave(). Ela é inteligente o suficiente para reconhecer o último gráfico criado como o gráfico a ser salvo. Assim, basta criar um gráfico qualquer e logo em seguida usar ggsave() para o salvar. Contudo, uma melhor prática é armazenar o gráfico criado em um objeto ou variável e usar essa referência em ggsave. Por exemplo: # Salvar um grafico de pontos no objeto &quot;p&quot; p &lt;- df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() # exibindo p p ## Warning: Removed 7 rows containing missing values (geom_point). # salvando p no computador ggsave(filename = &quot;meu grafico de pontos.png&quot;, plot = p) ## Saving 7 x 5 in image ## Warning: Removed 7 rows containing missing values (geom_point). Referências: Documentação de ggsave() 2.8 Juntando diferentes gráficos em um só O pacote patchwork tornou muito fácil juntar diferentes gráficos produzidos com ggplot2 em um só, algo mais complexo do que seria por facets. Por exemplo, para juntar os gráficos de barra e o de pontos feitos logo no início do módulo, basta salvar cada gráfico em um objeto e os juntar com um sinal de adição +: # salvar grafico de barras no objeto abaixo graf_barras &lt;- df_2017 %&gt;% group_by(continent) %&gt;% summarise(life_ladder = mean(life_ladder)) %&gt;% ggplot(aes(x = continent, y = life_ladder)) + geom_col() # salvar grafico de pontos no objeto abaixo graf_pontos &lt;- df_2017 %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() # juntando os dois graficos em um so: graf_barras + graf_pontos ## Warning: Removed 7 rows containing missing values (geom_point). O patchwork possui suas próprias customizacões. Uma delas é alterar o layout para apenas uma coluna: # juntando os dois graficos em um so, com apenas uma coluna graf_barras + graf_pontos + plot_layout(ncol = 1) ## Warning: Removed 7 rows containing missing values (geom_point). Referências: Documentação do pacote patchwork 2.9 Gráficos no R além de ggplot2 O próprio base R (a instalação nativa do R, sem nenhum pacote adicional) possui suas próprias funções para produzir gráficos simples, como plot(), barplot() e hist(). Contudo, como produzir gráficos com mais recursos no base R é bem mais complicado que no ggplot2, não o abordaremos neste módulo. Por curiosidade, a referência abaixo pode ser consultada: Referências: Tutorial completo sobre gráficos com base R 2.10 Exercícios Vamos continuar usando o dataset de super-heróis! Importe o pacote tidyverse Importe o arquivo salvo herois_completo.csv no módulo anterior. Salve no objeto herois. Faça um gráfico de pontos da coluna weight em função de height. Observe os outliers no gráfico. Crie um novo dataframe sem esses pontos. Isto é, crie um novo dataframe chamado herois_limpo, filtrando os heróis com peso e altura entre 1 a 500. Use este dataframe para todos os próximos items. Refaça o item 2, atribuindo a cor verde para os pontos. Refaça o item 2, mapeando a cor dos pontos à variável publisher. Refaça o item 2, mapeando a cor dos pontos à variável gender Refaça o item 2, mapeando a cor dos pontos à variável gender e o formato (shape) dos pontos à variável flight Refaça o item 2, mapeando a cor dos pontos à variável gender, o formato (shape) dos pontos à variável flight e separando o gráfico em subgráficos (facets) usando a variável publisher. Refaça o item 2, mapeando a cor dos pontos à variável flight e separando o gráfico em subgráficos (facets) usando as variáveis publisher e gender. "],
["ggplot2-parte-ii.html", "Módulo 3 ggplot2 - parte II 3.1 Gráficos de relacionamentos entre variáveis contínuas: scatter plot 3.2 Gráficos de barras ou colunas 3.3 Gráficos de distribuições 3.4 Gráficos de séries temporais (linhas) 3.5 Mapas de calor 3.6 Texto 3.7 Áreas ou faixas sombreadas 3.8 Alterando aspectos visuais do gráfico com os temas 3.9 Títulos 3.10 Extensões do ggplot2 3.11 Exercícios", " Módulo 3 ggplot2 - parte II Neste módulo, usaremos estes pacotes. Confira se você já os tem instalados: library(tidyverse) library(janitor) library(readxl) # interface com series temporais do banco central: library(rbcb) # install.packages(&#39;rbcb&#39;) # jaja explico :) library(ggrepel) # install.packages(&#39;ggrepel&#39;) Usaremos o dataset do índice de felicidade salvo anteriormente: # importar dataset df_feliz &lt;- read_rds(&quot;dados_felicidade_2017.rds&quot;) head(df_feliz) ## # A tibble: 6 x 12 ## country year life_ladder log_gdp_per_cap… social_support ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghan… 2017 2.66 7.46 0.491 ## 2 Albania 2017 4.64 9.37 0.638 ## 3 Algeria 2017 5.25 9.54 0.807 ## 4 Argent… 2017 6.04 9.84 0.907 ## 5 Armenia 2017 4.29 9.03 0.698 ## 6 Austra… 2017 7.26 10.7 0.950 ## # ... with 7 more variables: healthy_life_expectancy_at_birth &lt;dbl&gt;, ## # freedom_to_make_life_choices &lt;dbl&gt;, perceptions_of_corruption &lt;dbl&gt;, ## # positive_affect &lt;dbl&gt;, negative_affect &lt;dbl&gt;, gini &lt;dbl&gt;, ## # continent &lt;chr&gt; 3.1 Gráficos de relacionamentos entre variáveis contínuas: scatter plot Scatterplot, ou gráfico de pontos, é um tipo de visualização especialmente útil para observar se existe uma relação entre duas variáveis contínuas (numéricas), de que tipo ela é e se existem indivíduos que são fogem do comportamento padrão da maioria dos pontos. Observer o nosso dataset do índice de felicidade. Existem várias combinações de variáveis que poderíamos olhar. Por exemplo, qual será a relação entre PIB per capita e expectativa de vida saudável? df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() ## Warning: Removed 7 rows containing missing values (geom_point). Apenas com esse simples gráfico, aprendemos algumas informações sobre o dataset: * Conforme o esperado, existe uma correlação positiva entre as variáveis: quanto maior o PIB per capita do país, maior a expectativa de sua população. * Contudo, existem alguns pontos que fogem dessa relação, como os que possuem log PIB per capita de 8,5 mas expectativa de vida em torno de apenas 45 anos. Gráficos de pontos funcionam muito bem em conjunto com geom_smooth(). Observe como os comentários que fizemos sobre as propriedades dessas duas variáveis ficam ainda mais evidentes após adicionar a camada geom_smooth(): df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + # adicionar reta de ajuste de um modelo linear geom_smooth(method = &quot;lm&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). ## Warning: Removed 7 rows containing missing values (geom_point). A função geom_point() depende apenas de dois elementos obrigatórios para funcionar: x e y. Contudo, como já vimos, podemos definir opcionalmente outras propriedades visuais dos pontos, seja com valores absolutos ou mapeando variáveis a eles. Observe o exemplo abaixo: df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point(aes(color = continent)) ## Warning: Removed 7 rows containing missing values (geom_point). Ao acrescentar o elemento de cor, aprendemos que praticamente todos os países no quadrante de baixo PIB per capita e expectativa de vida são africanos. Em algumas situações, faz mais sentido usar facets para separar pontos de acordo com uma variável categórica: df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + facet_wrap(~ continent) ## Warning: Removed 7 rows containing missing values (geom_point). Referências: geom_point() 3.2 Gráficos de barras ou colunas Gráficos de barras ou colunas são uma ótima maneira de resumir um conjunto de dados, principalmente quando o objeto da análise é uma variável categórica. Existem duas principais maneiras de criar um gráfico de barras no ggplot2: geom_bar() e geom_col(). geom_bar representa a altura de cada barra proporcional ao número de casos em cada grupo da variável categórica. Caso se deseja representar a altura das barras de acordo com alguma variável numérica presente no dataset. Assim, geom_bar() precisa apenas da aesthetic x, enquanto geom_col() precisa das aesthetics x e y, onde y é a variável numérica a qual a altura das barras representará, proporcionalmente. Por exemplo, uma boa maneira de mostrar quantos países de cada continente estão presentes no nosso dataset é por meio de um gráfico de barras: df_feliz %&gt;% ggplot(aes(x = continent)) + geom_bar() É possível fazer exatamente o mesmo gráfico acima com geom_col() sendo apenas necessário transformar os dados antes: # agrupar os dados e contar a quantidade de países por continente df_feliz %&gt;% group_by(continent) %&gt;% summarise(qtd_paises = n()) %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() Diferentemente de geom_point(), a aesthetic color das barras define apenas a cor das bordas. Para mudar a cor das barras, deve-se alterar o parâmetro fill: df_feliz %&gt;% group_by(continent) %&gt;% summarise(qtd_paises = n()) %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col(color = &quot;red&quot;, fill = &quot;gray70&quot;) No exemplo abaixo, usamos geom_col() para plotar os países com os 10 maiores índices de felicidades, com as barras coloridas pelo continente, mapeando essa variável na aesthetic fill: df_feliz %&gt;% # selecionar o top 10 em indice de felicidade top_n(10, life_ladder) %&gt;% ggplot(aes(x = country, y = life_ladder)) + geom_col(aes(fill = continent)) 3.2.1 Invertendo eixos No exemplo acima, os nomes dos países se sobrepuseram devido ao seu tamanho. Nessa e em outra situações, é desejável inverter os eixos do gráfico, o que é feito com a função coord_flip(): df_feliz %&gt;% # selecionar o top 10 em indice de felicidade top_n(10, life_ladder) %&gt;% ggplot(aes(x = country, y = life_ladder)) + geom_col(aes(fill = continent)) + # inverter eixos coord_flip() 3.2.2 Como mudar a ordem das barras Uma tarefa muito comum ao fazer gráfico de barras é mudar a ordem das barras. Por padrão, o ggplot2 mantém a ordem dos leveis da variável, que é a alfabética (em casos onde ela não foi definida manualmente). É possível, no entanto, mudar a ordem das barras de forma que ela siga a mesma da variável contínua representada no gráfico ou até mesmo de uma outra presente no dataset. Vamos refazer o gráfico de quantidade de países por continente, dessa vez reordenado as barras: # agrupar os dados e contar a quantidade de países por continente df_feliz %&gt;% group_by(continent) %&gt;% summarise(qtd_paises = n()) %&gt;% # transformar variavel continent, mudando a ordem de seus leveis mutate(continent = reorder(continent, qtd_paises)) %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() Para inverter a ordem, isto é, plotar as barras em ordem decrescente, basta apenas escrever um sinal de menos (-) antes da variável contínua: # agrupar os dados e contar a quantidade de países por continente df_feliz %&gt;% group_by(continent) %&gt;% summarise(qtd_paises = n()) %&gt;% # transformar variavel continent, mudando a ordem de seus leveis mutate(continent = reorder(continent, -qtd_paises)) %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() Referências: geom_bar() e geom_col() 3.3 Gráficos de distribuições Existe uma família de gráficos dedicada a representar visualmente a distribuição de uma determinada variável contínua, com o objetivo de observar aspectos como média da distribuição, desvio padrão da média, presença de outliers, formato da distribuição, etc. 3.3.1 Histogramas Histograma é um método de sumarizar uma variável contínua a dividindo em segmentos ou intervalos (bins, em inglês) e contando quantas observações estão presentes em cada intervalo. O que difere o histograma de um gráfico de barras é o tipo da variável, pois o último lida com variáveis categóricas ou discretas, sendo os intervalos definidos pelos próprios valores que a variável assume, sem a necessidade de dividir em intervalos. No ggplot2, uma camada contendo um histograma é criada usando a função geom_histogram(), que só precisa de um elemento aesthetic: a variável do eixo x, que é aquela que se deseja estudar a distribuição. No nosso dataset de exemplo, o histograma pode ser usado para analisar a distribuição da expectativa de vida dos países: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. A função geom_histogram(), por padrão, “quebra” a variável em 30 intervalos. É possível mudar esse comportamento especificando o argumento bins: # reduzindo o numero de intervalos df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(bins = 10) # aumentando o número de intervalos df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(bins = 40) Outra maneira de redefinir os intervalos de um histograma é mudando o argumento binwidth, que controla a largura dos intervalos. Não é possível definir os argumentos bins e binwidth de uma só vez; ou um ou o outro. df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(binwidth = 5) No histograma acima, ao definir a largura dos intervalos como 5, o histograma criou intervalos usando como centros os números 45, 50, 55, etc. Portanto, os intervalos são [42,5 - 47,5), [47,5 - 52,5), etc. É possível també definir os limites dos intervalos. Por exemplo, caso você deseje que os intervalos comecem com números que terminem em 5, deve-se alterar o argumento boundary: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(binwidth = 5, boundary = 5) Assim, conseguimos criar uma visualização que mostra que a grande maioria dos países possui uma expectativa de vida maior que 60 anos, e que alguns poucos países possuem uma expectativa de vida menor que 50 anos e maior que 75. Como você já deve ter imaginado, é possível mudar aspectos visuais do histograma alterando suas aesthetics, como mudar a cor do histograma por valores atributos ou mapear alguma variável à cor do histograma. Veja que a cor de um histograma é definida pela propriedade fill, pois color altera apenas a cor das bordas das barras: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(binwidth = 5, boundary = 5, color = &quot;red&quot;, fill = &quot;green&quot;, alpha = 0.5) df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(binwidth = 5, boundary = 5, aes(fill = continent)) Histogramas agrupados, como o acima, não são muito bons para visualizar as diferenças entre os grupos. Fica um pouco melhor com facets: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_histogram(binwidth = 5, boundary = 5) + facet_wrap(~ continent, ncol = 1) Contudo, existem maneiras melhores de visualizar a distribuição de uma variável continua segmentada por diferentes grupos, como o que tentamos fazer acima. Exemplos são os gráficos dos próximos tópicos. Referências: geom_histogram() 3.3.2 Gráfico de densidade Ao trabalhar com uma variável contínua, uma alternativa a dividir os dados em intervalos e fazer um histograma é calcular a densidade de kernel estimada para a distribuição da variável. Parece complicado, mas a função geom_density() faz todo o trabalho por nós: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_density() Semelhantemente a um histograma, as aesthetics color e fill podem ser definidas, sendo a primeira para a borda e a segunda para o corpo da curva de densidade: df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_density(color = &quot;red&quot;, fill = &quot;green&quot;) O gráfico de densidade, por si só, não oferece muito mais em termos de interpretabilidade que um histograma. Seu grande triunfo está em observar como se comporta a distribuição da variável contínua definida na aesthetic x em diferentes grupos de uma variável categórica definida na aesthetic fill: df_feliz %&gt;% # remover oceania porque so tem dois paises filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth)) + geom_density(aes(fill = continent), # adicionar transparencia alpha = 0.5 ) A partir do gráfico de densidade acima, aprendemos algumas informações sobre nossos dados, como: * Não só a média da expectativa de vida da África é bem menor que a dos demais continentes, mas poucos países apresentam níveis dessa variável semelhantes a Europa, Asia e Americas. * Nenhuma das distribuições da variáveis nos quatro continentes aparenta ser normal: a da Europa, por exemplo, apresenta um formato bimodal. Essa pode ser uma informação importante para suas análises. Referências: Distribuição normal geom_density() 3.3.3 Boxplot Boxplot, ou diagramas de caixa, é uma outra maneira de estudar o comportamento de uma variável contínua segmentada por diferentes grupos de uma variável categórica. A função geom_boxplot() precisa de duas aesthetics: x, a variavel categórica, e y, a variável contínua: df_feliz %&gt;% # remover oceania porque so tem dois paises filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = continent, y = healthy_life_expectancy_at_birth)) + geom_boxplot() Um boxplot tenta resumir uma variável numérica usando 5 números: a mediana (linha central da caixa), o primeiro quartil ou 25% percentil (linha inferior), o terceiro quartil ou 75% percentil (linha superior) e uma margem definida pelos intervalos interquartis multiplicados por um fator, que por padrão é 1,58. Ou seja: \\(1.58 \\times IQR\\). Pontos fora desses limites seriam considerados outliers ou anomalias para aquele grupo. Em determinadas situações, é desejável inverter os eixos, transformando o gráfico em horizontal. Isso é possível por meio da função coord_flip() df_feliz %&gt;% filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = continent, y = healthy_life_expectancy_at_birth)) + geom_boxplot() + coord_flip() Também é possível criar uma subdivisão com boxplots usando o argumento fill. Por exemplo: # criar nova variavel que indica se um país possui um # indice de felicidade maior que 6 hist(df_feliz$life_ladder) df_feliz %&gt;% filter(continent != &quot;Oceania&quot;) %&gt;% mutate(indice_felicidade = if_else(life_ladder &gt; 6, &quot;acima de 6&quot;, &quot;abaixo&quot;)) %&gt;% ggplot(aes(x = continent, y = healthy_life_expectancy_at_birth)) + geom_boxplot(aes(fill = indice_felicidade)) Assim, com o gráfico acima descobrimos que países dentro de um mesmo continente que possuem índice de felicidade acima 6 possuem também maior expectativa de vida, o que era esperado. Nota-se que a caixa dos países da África com índice de felicidade acima de 6 ficou achatada porque só tem um país. Referências: geom_boxplot() 3.3.4 Jitter Uma maneira de incrementar um boxplot é plotar também todos os pontos, e não apenas os 5 que o boxplot representa. Isso pode ser feito com a função geom_jitter(), que é uma variação de geom_point() que adiciona uma pequena quantidade de variação aleatória na posição dos pontos, o que pode ser útil ao plotar pontos que sobreporiam devido a grande quantidade de indíviduos presentes em um mesmo intervalo de pontos. df_feliz %&gt;% # remover oceania porque so tem dois paises filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = continent, y = healthy_life_expectancy_at_birth)) + geom_boxplot() + geom_jitter(color = &quot;red&quot;) Uma curiosidade interessante do ggplot2 é que as camadas são criadas na ordem que são definidas. Observe a diferença do gráfico acima para o criado abaixo, onde a ordem das camadas de boxplot e jitter foi invertida: df_feliz %&gt;% # remover oceania porque so tem dois paises filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = continent, y = healthy_life_expectancy_at_birth)) + geom_jitter(color = &quot;red&quot;) + geom_boxplot() Referências: geom_jitter() 3.4 Gráficos de séries temporais (linhas) Série temporal é definida como uma variável contínua mensurada em intervalos regulares de tempo. A melhor representação visual para dados desse tipo são gráficos de linha, que são úteis para mostrar o comportamento de uma variável ao longo do tempo. Como exemplo para gráficos de linha, vamos plotar a evolução de dois importantes indicadores econômicos brasileiros: a taxa SELIC e o índice IPCA, ambos mensalizados. Para obter esses indicadores, usamos o pacote rbcb: # Importar para o R dados das series. lista_datasets &lt;- rbcb::get_series(code = c(ipca = 433, selic = 4390)) # O objeto retornado é uma lista de dois dataframes: str(lista_datasets) ## List of 2 ## $ ipca :Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 463 obs. of 2 variables: ## ..$ date: Date[1:463], format: &quot;1980-01-01&quot; ... ## ..$ ipca: num [1:463] 6.62 4.62 6.04 5.29 5.7 5.31 5.55 4.95 4.23 9.48 ... ## $ selic:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 387 obs. of 2 variables: ## ..$ date : Date[1:387], format: &quot;1986-06-01&quot; ... ## ..$ selic: num [1:387] 1.27 1.95 2.57 2.94 1.96 ... # Voce pode acessar cada dataframe usando a sintaxe NOME_DA_LISTA$NOME_DO_OBJETO: str(lista_datasets$selic) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 387 obs. of 2 variables: ## $ date : Date, format: &quot;1986-06-01&quot; &quot;1986-07-01&quot; ... ## $ selic: num 1.27 1.95 2.57 2.94 1.96 ... # Vamos então criar apenas um dataset que corresponde a junção dos dois dataframes df_st &lt;- left_join(lista_datasets$ipca, lista_datasets$selic, by = &quot;date&quot;) # conferindo o novo dataframe criado head(df_st) ## # A tibble: 6 x 3 ## date ipca selic ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1980-01-01 6.62 NA ## 2 1980-02-01 4.62 NA ## 3 1980-03-01 6.04 NA ## 4 1980-04-01 5.29 NA ## 5 1980-05-01 5.7 NA ## 6 1980-06-01 5.31 NA Temos uma coluna de data (date), cuja classe é Date e será usada como eixo x no gráfico de séries temporais: # grafico da taxa selic ggplot(df_st, aes(x = date, y = ipca)) + geom_line() É possível incluir no gráfico mais de uma variável no eixo y. Uma das alternativas é simplesmente acrescentar mais uma camada geom_line() com a nova variável: ggplot(df_st, aes(x = date, y = ipca)) + geom_line() + # adicionar mais uma camada de geom_line geom_line(aes(y = selic), color = &quot;blue&quot;) ## Warning: Removed 77 rows containing missing values (geom_path). No entanto, a melhor maneira de se fazer isso é converter os dados para o formato long (tidy): df_st_tidy &lt;- df_st %&gt;% gather(indicador, valor, ipca:selic) %&gt;% arrange(date) head(df_st_tidy) ## # A tibble: 6 x 3 ## date indicador valor ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1980-01-01 ipca 6.62 ## 2 1980-01-01 selic NA ## 3 1980-02-01 ipca 4.62 ## 4 1980-02-01 selic NA ## 5 1980-03-01 ipca 6.04 ## 6 1980-03-01 selic NA # antes de proceder com o restante do exercicio, vamos salvar o dataset para # o usar nos proximos modulos write_rds(df_st_tidy, &quot;series_ipca_selic.rds&quot;) Note que indicador é uma coluna categórica e valor, numérica. Portanto, a primeira será mapeada à aesthetic y e a segunda a color. Agora, a variável indicador é mapeada ao atributo color. df_st_tidy %&gt;% ggplot(aes(x = date, y = valor, color = indicador)) + geom_line() ## Warning: Removed 77 rows containing missing values (geom_path). Notou como o período antes de 1995 representava uma realidade muito diferente da atual? Vamos então filtrar os dados a partir desse ano. df_st_pos_1995 &lt;- df_st_tidy %&gt;% filter(date &gt;= as.Date(&quot;1995-01-01&quot;)) df_st_pos_1995 %&gt;% ggplot(aes(x = date, y = valor, color = indicador)) + geom_line() Referências: geom_line() 3.4.1 Personalizando a escala do eixo de datas Observe o último gráfico. O ggplot2, internamente, “quebrou” o eixo x em intervalos de 5 anos. Esse aspecto do gráfico pode ser alterado usando a função scale_x_date, usando o argumento date_breaks: ggplot(df_st_pos_1995, aes(x = date, y = valor, color = indicador)) + geom_line() + scale_x_date(date_breaks = &quot;2 year&quot;) Ao mudar o argumento date_breaks, o gráfico perdeu a representação de datas anterior, que antes só mostrava o ano. Para voltar ao formato anterior, pode-se alterar o formato das datas usando o argumento date_labels da mesma função: ggplot(df_st_pos_1995, aes(x = date, y = valor, color = indicador)) + geom_line() + scale_x_date(date_breaks = &quot;2 year&quot;, date_labels = &quot;%Y&quot;) 3.5 Mapas de calor Até agora, estudamos gráficos para representar as relações entre: * Uma variavél categórica com ou sem uma numérica (gráficos de barra) * Duas numéricas (gráficos de pontos) * Uma numérica (histogramas e boxplots) * Uma numérica ao longo do tempo (gráficos de linhas) Para representar uma relação um pouco mais complexa, a de duas variáveis categóricas e uma numérica, pode-se usar um mapa de calor. Suponha que você deseja plotar a correlação entre todos os possíveis pares de correlação das variáveis de um dataset: # calcular correlacao entre as variaveis numericas do dataset de felicidade df_feliz_num &lt;- df_feliz %&gt;% select(life_ladder, log_gdp_per_capita, social_support, healthy_life_expectancy_at_birth, gini, perceptions_of_corruption) %&gt;% # removar NAs na.omit() # criar matriz de correlacao matriz_correl &lt;- cor(df_feliz_num) # de uma olhada no objeto criado # matriz_correl # transformar para dataframe matriz_correl &lt;- as.data.frame(matriz_correl) # conveter rownames para uma coluna matriz_correl &lt;- rownames_to_column(matriz_correl, &quot;var1&quot;) # converter dataframe para formato tidy matriz_correl_tidy &lt;- matriz_correl %&gt;% gather(var2, correlacao, -var1) head(matriz_correl_tidy) ## var1 var2 correlacao ## 1 life_ladder life_ladder 1.0000000 ## 2 log_gdp_per_capita life_ladder 0.7549421 ## 3 social_support life_ladder 0.7647823 ## 4 healthy_life_expectancy_at_birth life_ladder 0.7304080 ## 5 gini life_ladder -0.4581271 ## 6 perceptions_of_corruption life_ladder -0.5000318 Assim, no dataframe var1 e var2, temos duas variáveis categóricas (os pares de variáveis) e uma numérica (a correlação entre as duas variáveis). A função do ggplot2 para criar um mapa de calor é geom_tile, que precisa de três aesthetics: os eixos x e y, que são as variáveis categóricas, e fill, que será a variável contínua que definirá a cor dos quadrados: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() Devido ao tamanho dos nomes das variáveis, o eixo x ficou difícil de ler. Uma solução é mudar o ângulo dos nomes, isto é, colocá-los na vertical. A função theme(), que ainda será mostrada em detalhes neste módulo, possui um argumento para fazer isso: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + theme(axis.text.x = element_text(angle = 90)) Caso você não tenha gostado da escala de cores em azul definida por padrão pelo ggplot2, é possível mudar usando a função scale_fill_distiller: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + scale_fill_distiller( # alterar o tipo da escala. pode ser divergente, sequencial e categorica type = &quot;div&quot;, # alterar a paleta. confira os possiveis valores na documentacao da funcao palette = &quot;RdBu&quot;, # inverter a direcao direction = 1 ) + theme(axis.text.x = element_text(angle = 90)) Referências: Documentação da função geom_tile() Material sobre funções da família scale, seção 9.3. 3.6 Texto As funções geom_text() e geom_label() servem para acrescentar camadas de texto no gráfico. A única diferença entre as duas é que geom_label() desenha um retângulo no fundo do texto, possivelmente melhorando sua leitura. Ambas funções geom_text() dependem de três aesthetics: x e y, que correspondem às posições dos textos a serem plotados, e label, que é o texto a ser plotado. No exemplo abaixo, não especificamos x e y em geom_text() porque a função herda as definidas na função ggplot(): # agrupar os dados e contar a quantidade de países por continente df_feliz_agg &lt;- df_feliz %&gt;% group_by(continent) %&gt;% summarise(qtd_paises = n()) df_feliz_agg ## # A tibble: 5 x 2 ## continent qtd_paises ## &lt;chr&gt; &lt;int&gt; ## 1 Africa 38 ## 2 Americas 20 ## 3 Asia 41 ## 4 Europe 40 ## 5 Oceania 2 df_feliz_agg %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() + # adicionar camada de texto geom_text(aes(label = qtd_paises)) Observe a diferença de geom_label(): df_feliz_agg %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() + # adicionar camada de texto geom_label(aes(label = qtd_paises)) É possível alterar a posição da camada de texto no gráfico alterando os argumentos vjust e hjust: df_feliz_agg %&gt;% ggplot(aes(x = continent, y = qtd_paises)) + geom_col() + # adicionar camada de texto geom_text(aes(label = qtd_paises), # mudar posicao para mais baixo vjust = 1, # mudar posicao para mais a direita hjust = -1, # porque nao, alterar tambem a cor color = &quot;white&quot; ) Suponha que no primeiro gráfico de pontos mostrado no material, que mostra a relação entre PIB per capita e expectativa de vida, você deseja também acrescentar os nomes dos países: df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + geom_text(aes(label = country)) ## Warning: Removed 7 rows containing missing values (geom_point). ## Warning: Removed 7 rows containing missing values (geom_text). Como era de se esperar, o gráfico ficou muito poluído. Vamos então reduzir os pontos que queremos mostrar os nomes dos respectivos países apenas aos países dos continentes americanos. A estrategia, então, consiste em criar um novo dataframe com esses países e mudar o argumento data em geom_text: america &lt;- df_feliz %&gt;% filter(continent == &quot;Americas&quot;) df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + geom_text(data = america, aes(label = country)) ## Warning: Removed 7 rows containing missing values (geom_point). Melhorou, mas ainda assim ficou poluído. Uma boa solução para esse problema é o pacote ggrepel, que internamente calcula a melhor posição entre os pontos da camada de texto, seja geom_text() ou geom_label(), de forma que não haja conflito de posição entre pontos. A única alteração necessária é mudar geom_text para geom_text_repel: df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point() + geom_text_repel(data = america, aes(label = country)) ## Warning: Removed 7 rows containing missing values (geom_point). Outro gráfico mostrado anteriormente neste material que pode ser melhorado é o mapa de calor, acrescentando uma camada de texto que mostre o valor numérico da correlação entre as variáveis: matriz_correl_tidy %&gt;% ggplot(aes(x = var1, y = var2, fill = correlacao)) + geom_tile() + scale_fill_distiller( # alterar o tipo da escala. pode ser divergente, sequencial e categorica type = &quot;div&quot;, # alterar a paleta. confira os possiveis valores na documentacao da funcao palette = &quot;RdBu&quot;, # inverter a direcao direction = 1 ) + theme(axis.text.x = element_text(angle = 90)) + # adicionar camada de texto. é recomendável arredondar os numeros geom_text(aes(label = round(correlacao, 2))) geom_text() e geom_label() também podem ser usadas de maneira mais individualizada, ou seja, para adicionar anotações textuais em partes específicas do gráfico definidas pelo usuário. Observe o gráfico abaixo: p2 &lt;- df_st %&gt;% filter(date &gt;= as.Date(&quot;2016-01-01&quot;)) %&gt;% ggplot(aes(x = date, y = selic)) + geom_line()+ # quebrar o eixo x a cada 3 meses scale_x_date( date_breaks = &quot;2 month&quot;, # mostrar eixos no formato mes/ano date_labels = &quot;%m/%y&quot; ) + theme_minimal() p2 A taxa Selic caiu bastante em 2017. Que tal acrescentar esse comentário na área do gráfico? Isso pode ser definindo definindo manualmente as aesthetics de geom_text() ou geom_label(): p2 + geom_label( x = as.Date(&quot;2018-02-01&quot;), y = 1, # Usamos o caracter especial \\n para adicionar uma quebra de linha label = &quot;A taxa SELIC apresentou \\ntendência de queda em 2017&quot; ) Referências: geom_text() 3.7 Áreas ou faixas sombreadas A função geom_rect pode ser usada para criar faixas sombreadas para destacar alguma parte específica do gráfico. No gráfico anterior, destacar o ano de 2017 no gráfico usando uma área sombreada: p2 + geom_rect( xmin = as.Date(&quot;2017-01-01&quot;), xmax = as.Date(&quot;2017-12-01&quot;), ymin = -Inf, ymax = Inf, # deixar o retangulo mais transparente alpha = 0.01 ) Destacar uma faixa numérica relativa ao eixo y de interesse: p2 + geom_rect( # a geom rect precisa de 4 aesthetics: xmin = -Inf, xmax = Inf, ymin = 0.6, ymax = 0.8, # mudar cor do retangulo para vermelho fill = &quot;red&quot;, # deixar a area sombreada mais transparente alpha = 0.01 ) Outra maneira de criar faixas sombreadas, desta vez dependendo do valor de uma variável, é usando a função geom_ribbon(). No exemplo da série acima, suponha que queiramos destacar uma faixa em torno da taxa Selic: p2 + geom_ribbon(aes(ymin = -0.1 + selic, ymax = 0.1 + selic), fill = &quot;grey&quot;, alpha = 0.4) 3.8 Alterando aspectos visuais do gráfico com os temas Um tema, no ggplot2, é definido como um conjunto de propriedades visuais, como fonte, cor do painel de fundo, posição da legenda, etc. O tema padrão do ggplot2, caracterizado principalmente pelo fundo cinza, pode ser mudado para temas pré-definidos no pacote: # grafico padrao a ser modificado p &lt;- df_feliz %&gt;% ggplot(aes(x = log_gdp_per_capita, y = healthy_life_expectancy_at_birth)) + geom_point(aes(color = continent)) + facet_grid(~ continent) p ## Warning: Removed 7 rows containing missing values (geom_point). # usar tema bw: p + theme_bw() ## Warning: Removed 7 rows containing missing values (geom_point). # usar tema minimal: p + theme_minimal() ## Warning: Removed 7 rows containing missing values (geom_point). # tema classico p + theme_classic() ## Warning: Removed 7 rows containing missing values (geom_point). # tema dark p + theme_dark() ## Warning: Removed 7 rows containing missing values (geom_point). Contudo, caso você não deseje usar o tema padrão mas mesmo assim quer alterar algumas propriedades visuais do gráfico, deve-se usar a função theme(). Esta é alista de todas as possíveis propriedades que podem ser alteradas: args(theme) ## function (line, rect, text, title, aspect.ratio, axis.title, ## axis.title.x, axis.title.x.top, axis.title.x.bottom, axis.title.y, ## axis.title.y.left, axis.title.y.right, axis.text, axis.text.x, ## axis.text.x.top, axis.text.x.bottom, axis.text.y, axis.text.y.left, ## axis.text.y.right, axis.ticks, axis.ticks.x, axis.ticks.x.top, ## axis.ticks.x.bottom, axis.ticks.y, axis.ticks.y.left, axis.ticks.y.right, ## axis.ticks.length, axis.line, axis.line.x, axis.line.x.top, ## axis.line.x.bottom, axis.line.y, axis.line.y.left, axis.line.y.right, ## legend.background, legend.margin, legend.spacing, legend.spacing.x, ## legend.spacing.y, legend.key, legend.key.size, legend.key.height, ## legend.key.width, legend.text, legend.text.align, legend.title, ## legend.title.align, legend.position, legend.direction, legend.justification, ## legend.box, legend.box.just, legend.box.margin, legend.box.background, ## legend.box.spacing, panel.background, panel.border, panel.spacing, ## panel.spacing.x, panel.spacing.y, panel.grid, panel.grid.major, ## panel.grid.minor, panel.grid.major.x, panel.grid.major.y, ## panel.grid.minor.x, panel.grid.minor.y, panel.ontop, plot.background, ## plot.title, plot.subtitle, plot.caption, plot.tag, plot.tag.position, ## plot.margin, strip.background, strip.background.x, strip.background.y, ## strip.placement, strip.text, strip.text.x, strip.text.y, ## strip.switch.pad.grid, strip.switch.pad.wrap, ..., complete = FALSE, ## validate = TRUE) ## NULL Como você percebeu, a lista é imensa. Por isso, vamos nos restringir neste material a alguns exemplos do que pode ser feito: Alterar a posição da legenda: p + theme(legend.position = &quot;bottom&quot;) ## Warning: Removed 7 rows containing missing values (geom_point). Remover os minor grids de um eixo: p + # remover minor grids do eixo x theme(panel.grid.minor.y = element_blank()) ## Warning: Removed 7 rows containing missing values (geom_point). Mudar cor de fundo: p + theme(panel.background = element_rect(fill = &quot;azure&quot;)) ## Warning: Removed 7 rows containing missing values (geom_point). Referências: Confira todos os temas pré-definidos do ggplot2 theme() Uma das grandes vantagens do ggplot2 é que basicamente tudo no gráfico é customizável. A função theme é usada para modificar componentes individuais de um tema 3.9 Títulos Os títulos de todos os elementos de um gráfico, como os dos eixos, das legendas, do próprio título do gráfico, etc., podem ser alterados usando a função labs(): p + labs(x = &quot;Log da PIB per capita&quot;, y = &quot;Expectativida de vida em anos&quot;, title = &quot;Relação entre PIB per capita e expectativida de vida&quot;, subtitle = &quot;Existe uma correlação positiva entre as duas variáveis&quot;, # Aqui usamos &#39;\\n&#39;, um character especial do R, para # adicioanar uma quebra de linha color = &quot;Continente\\n do país&quot;, caption = &quot;Autor: Eu&quot;) ## Warning: Removed 7 rows containing missing values (geom_point). Referências: labs() 3.10 Extensões do ggplot2 O ggplot2 é tão flexível e popular que se criou uma comunidade enorme em torno no pacote. Aos poucos, outros programadores foram criando extensões para o pacote que fornecem ainda mais opções de visualizações para o usuário comum. Referências: Extensões do ggplot2 3.11 Exercícios Importe o arquivo salvo herois_completo.csv no primeiro módulo. Salve no objeto herois. Filtre os herois que possuem peso e altura maior que 0. Crie um histograma da variável altura. Analise a distribuição da variável peso em função da editora dos heróis. Crie um gŕafico de barras mostrando a quantidade de heróis por editora. Ordene as barras em ordem descrescente. Acrescente uma camada de texto nas barras mostrando a quantidade exata. Crie um gráfico de barras mostrando a quantidade de herois bons, maus ou neutros (variável alignment) por editora. Use tanto geom_bar() como geom_col() para isso, usando o argumento position = position_dodge() para separar as barras nas editoras. Repita o item anterior, trocando apenas o parâmeto position = position_dodge() para position = position_fill() para observar a proporção de personagens bons, maus ou neutros em cada editora. Use o dplyr e o tidyr para criar um dataset chamado hero_agg, que contem a quantidade de poderes agregado por editora e heroi. Dica: transforme as colunas de super-poderes em numéricas, converta o dataframe para formato tidy, agrupe os dados por editora e heroi e calcule a soma da coluna transformada de poderes. Faça um gráfico de barras mostrando os 10 herois de cada editora que possuem mais poderes. Dica: use facets para separa os herois de cada editora, usando scales = &quot;free_y&quot; e drop = TRUE. Inverta os eixos. Faça um gráfico de densidade da distribuição da quantidade de poderes dos herois por editora. Use o parâmetro alpha para aumentar a transparência das curvas. Para praticar com gráficos de séries temporais, usaremos outro dataset. Importe o dataset economics usando a função data(). Observe os dados com a função head(). Qual a periodicidade temporal dos dados (ex.: diário, semanal, mensal, anual) ? Faça um gráfico da variável unemploy ao longo do tempo. Salve esse gráfico no objeto p, que será usado nos próximos itens. Acrescente uma camada de área sombreada destacando o período entre 2001 a 2005. Acrescente algum comentário seu no gráfico usando a função geom_text(). Transforme o dataframe economics para o formato tidy. Faça um gráfico de linha de todos os indicadores econômicos ao longo do tempo, mapeando a aesthetic color à variável do nome do indicador. Note os problemas de escala do gráfico. Repita o item anterior, acrescentando uma camada de facets que separe os gráficos por indicador. Defina o parâmetro scales para ter escala livre no eixo y. "],
["outros-tipos-de-graficos.html", "Módulo 4 Outros tipos de gráficos 4.1 Transformando gráficos do ggplot2 em interativos 4.2 Mapas: plotando polígonos 4.3 Mapas: plotando pontos com Google Maps 4.4 Mapas interativos 4.5 Gráficos de dados hierárquicos: treemaps e sunburst 4.6 Exercícios", " Módulo 4 Outros tipos de gráficos Pacotes deste módulo: # importar pacotes # install.packages(c(&quot;plotly&quot;, &quot;sf&quot;, &quot;ggmap&quot;, &quot;sunburstR&quot;, &quot;leaflet&quot;, &quot;treemap&quot;)) # devtools::install_github(&quot;italocegatta/brmap&quot;) library(tidyverse) library(plotly) library(sf) library(ggmap) library(sunburstR) library(leaflet) library(treemap) library(brmap) Continuaremos alguns datasets usados nos módulos anteriores: # importar datasets # indice de felicidade df_feliz &lt;- read_rds(&quot;dados_felicidade_2017.rds&quot;) # dados econômicos df_series &lt;- read_rds(&quot;series_ipca_selic.rds&quot;) 4.1 Transformando gráficos do ggplot2 em interativos É possível ainda dar ainda mais vida aos seus gráficos os transformando em interativos de maneira muito fácil. O pacote plotly, além de ser um ótimo pacote para produzir gráficos interativos em R ou Python, possui uma funcão chamada ggplotly() que transforma um gráfico estático do ggplot2 em interativo. Vamos recriar um dos gráficos construídos anteriormente, salvar em um objeto e o transformar em interativo: # grafico do pib per capita em funcao da expectativa de vida p &lt;- df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth, y = log_gdp_per_capita)) + geom_point(aes(color = continent)) + geom_smooth(method = &quot;lm&quot;) + theme_minimal() # converter para interativo ggplotly(p) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). Com apenas uma simples função, temos um gráfico cheio de recursos interativos, como possibilidade de dar zoom em áreas específicos do gráfico e tooltips, que é a pequena tabela de dados que aparece na tela ao passar o mouse em um ponto ou na reta criada por geom_smooth(). Como era de se esperar, as tooltips também podem ser customizadas. A função ggplotly possui um parâmetro chamado tooltip onde pode ser especificada a aesthetic que será mostrada na tooltip. Por padrão, como você viu, a tooltip mostra todas as aesthetics definidas no gráfico. Caso você queira mudar esse aspecto, pode mudar o valor desse parâmetro em ggplotly: # mostrar apenas a aesthetic x, # na qual foi mapeada a variavel de expectativa de vida ggplotly(p, tooltip = &quot;x&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). # mostrar apenas a aesthetic color, # na qual foi mapeada a variavel de continent ggplotly(p, tooltip = &quot;color&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). Incrivelmente, dá para ficar ainda melhor. É definindo uma nova aesthetic chamada text, que por padrão não pertence ao ggplot2 mas é usada pelo plotly para construir a tooltip. Essa nova aesthetic, usada em combinação com a função paste0, pode criar tooltips informativas e elegantes. Caso não conheça a função paste0(), ela serve para concatenar vetores de strings em um só, de maneira paralelizada. Segue alguns exemplos: nome &lt;- c(&quot;Lucas&quot;, &quot;Eduardo&quot;, &quot;Flávio&quot;) sobrenome &lt;- c(&quot;Silva&quot;, &quot;Oliveira&quot;, &quot;Dias&quot;) # concatenar os dois vetores acima, juntando nome e sobrenome com espaço no meio paste0(nome, &quot; &quot;, sobrenome) ## [1] &quot;Lucas Silva&quot; &quot;Eduardo Oliveira&quot; &quot;Flávio Dias&quot; Usando essa função, vamos definir a aesthetic de forma que mostre o nome dos países e os valores das variáveis dos eixos: # refazer o grafico, definindo uma nova aesthetic chamada text: p &lt;- df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth, y = log_gdp_per_capita)) + geom_point(aes(color = continent, text = paste0(country, healthy_life_expectancy_at_birth, log_gdp_per_capita) )) + geom_smooth(method = &quot;lm&quot;) + theme_minimal() ## Warning: Ignoring unknown aesthetics: text ggplotly(p, tooltip = &quot;text&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). Passe o mouse nos pontos e veja o resultado. Note que foi possível incluir a variável do nome do país no gráfico, mesmo não estando definida em nenhuma aesthetic além de text. Contudo, a tooltip não ficou muito visualmente agradável, correto? Isso porque ficou tudo em uma linha só. Felizmente, é possível fazer melhor usando a função paste0 ao nosso favor (Lembre-se que \\n é um caracter especial do R que serve para quebrar linhas): p &lt;- df_feliz %&gt;% ggplot(aes(x = healthy_life_expectancy_at_birth, y = log_gdp_per_capita)) + geom_point(aes(color = continent, text = paste0( &quot;País: &quot;, country, &quot;\\n&quot;, &quot;Expec. vida: &quot;, round(healthy_life_expectancy_at_birth, 0), &quot;\\n&quot;, &quot;PIB per capita (log): &quot; , round(log_gdp_per_capita, 2) ))) + geom_smooth(method = &quot;lm&quot;) + theme_minimal() ## Warning: Ignoring unknown aesthetics: text ggplotly(p, tooltip = &quot;text&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). 4.1.1 Salvando um gráfico ggplotly Para salvar um gráfico produzido pelo plotly, basta salvar em um objeto e usar a função saveWidget, do pacote htmlwidgets, que é instalado junto com o plotly. O gráfico deve ser salvo com a extensão html e pode ser aberto usando um browser, como o Firefox. p_interativo &lt;- ggplotly(p, tooltip = &quot;text&quot;) ## Warning: Removed 7 rows containing non-finite values (stat_smooth). # salve htmlwidgets::saveWidget(p_interativo, &quot;meu_grafico_interativo.html&quot;) Referências: Site do pacote plotly 4.2 Mapas: plotando polígonos Produzir mapas com o R nunca foi tão fácil como hoje, graças a avanços recentes dos pacotes sf e ggplot2. Foge muito do escopo deste curso explicar a estrutura de dados espaciais, como shapefiles. Mesmo sem esse entedimento, porém, é possível fazer gráficos com mapas de maneira muito simples. O pacote brmap, desenvolvido pelo brasileiro Ítalo Cegatta, facilita a importação de arquivos shapefiles fornecidos no site do IBGE. Existem shapefiles para municípios (brmap_municipio), estados (brmap_estado), regiões (brmap_regiao) e o país (brmap_brasil). # importar o shp de estados data(brmap_estado) head(brmap_estado) ## Simple feature collection with 6 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.07095 ymax: 5.271841 ## epsg (SRID): 4674 ## proj4string: +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ## # A tibble: 6 x 5 ## cod_regiao cod_estado estado_nome estado_sigla geometry ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;POLYGON [°]&gt; ## 1 1 11 Rondônia RO ((-62.86662 -7.975868, -… ## 2 1 12 Acre AC ((-73.18253 -7.335496, -… ## 3 1 13 Amazonas AM ((-67.32609 2.029714, -6… ## 4 1 14 Roraima RR ((-60.20051 5.264343, -6… ## 5 1 15 Pará PA ((-54.95431 2.583692, -5… ## 6 1 16 Amapá AP ((-51.1797 4.000081, -51… Observe que o dataframe possui quatro colunas, sendo a última relacionada às informações espaciais sobre os polígonos dos estados que serão usadas para construir os mapas. A sintaxe do ggplot2 para construir mapas é relativamente diferente: não é preciso definir nenhuma aesthetic, pois a função geom_sf internamente busca a coluna de polígonos presente no objeto: ggplot(brmap_estado) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geometry)) geom_sf() A partir do gráfico base criado acima, as customizações seguem o padrão do ggplot2. Por exemplo, é possível mapear a cor os polígonos de acordo com uma variável presente nos dados, além de alterar aspectos visuais com a função theme: ggplot(brmap_estado) + # a linha abaixo da no mesmo que geom_sf(aes(geometry = geometry)) geom_sf(aes(geometry = geometry, # colorir os poligonos de acordo com sua regiao fill = as.character(cod_regiao))) + # deixar o mapa mais limpo e sem eixos theme( panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + # mudar titulo da legenda labs(fill = &quot;Região&quot;) 4.2.1 Projeto: plotando o resultado do segundo turno das eleições para presidente de 2014 por UF: Neste exemplo, mostramos como o ggplot2 pode ser usado para produzir mapas muito informativos, mapeando a cor de cada polígono a uma variável numérica, como PIB ou população. Neste caso, usamos dados eleitorais das eleições para Presidência da República no segundo turno de 2014, vencida pelo PT contra o PSDB. Observe o passo-a-passo de coleta e transformação dos dados das eleições: # baixar dados do TSE de votação por municipio e zona link &lt;- &quot;http://agencia.tse.jus.br/estatistica/sead/odsele/votacao_partido_munzona/votacao_partido_munzona_2014.zip&quot; download.file(link, destfile = &quot;tse.zip&quot;) # descompactar arquivo unzip(&quot;tse.zip&quot;) # definir vetor com nomes das colunas cols &lt;- c(&quot;DATA_GERACAO&quot;, &quot;HORA_GERACAO&quot;, &quot;ANO_ELEICAO&quot;, &quot;NUM_TURNO&quot;, &quot;DESCRICAO_ELEICAO&quot;, &quot;SIGLA_UF&quot;, &quot;SIGLA_UE&quot;, &quot;CODIGO_MUNICIPIO&quot;, &quot;NOME_MUNICIPIO&quot;, &quot;NUMERO_ZONA&quot;, &quot;CODIGO_CARGO&quot;, &quot;DESCRICAO_CARGO&quot;, &quot;TIPO_LEGENDA&quot;, &quot;NOME_COLIGACAO&quot;, &quot;COMPOSICAO_LEGENDA&quot;, &quot;SIGLA_PARTIDO&quot;, &quot;NUMERO_PARTIDO&quot;, &quot;NOME_PARTIDO&quot;, &quot;QTD_VOTOS_NOMINAIS&quot;, &quot;QTD_VOTOS_LEGENDA&quot;, &quot;TRANSITO&quot;) # conveter para minusculo cols &lt;- str_to_lower(cols) # definir encoding lcl &lt;- locale(encoding = &quot;ISO-8859-1&quot;) # ler arquivo eleicoes &lt;- read_csv2(&quot;/home/sillas/R/data/eleicoes_2014/votacao_partido_munzona_2014/votacao_partido_munzona_2014_BR.txt&quot;, col_names = FALSE, locale = lcl, progress = FALSE) %&gt;% # remover ultima coluna select(-22) %&gt;% # mudar nome das colunas set_names(cols) head(eleicoes) ## # A tibble: 6 x 21 ## data_geracao hora_geracao ano_eleicao num_turno descricao_eleic… sigla_uf ## &lt;chr&gt; &lt;time&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 17/05/2018 04:15 2014 2 Eleições Gerais… PB ## 2 17/05/2018 04:15 2014 2 Eleições Gerais… PR ## 3 17/05/2018 04:15 2014 2 Eleições Gerais… PR ## 4 17/05/2018 04:15 2014 2 Eleições Gerais… RS ## 5 17/05/2018 04:15 2014 2 Eleições Gerais… MT ## 6 17/05/2018 04:15 2014 2 Eleições Gerais… PB ## # ... with 15 more variables: sigla_ue &lt;chr&gt;, codigo_municipio &lt;chr&gt;, ## # nome_municipio &lt;chr&gt;, numero_zona &lt;int&gt;, codigo_cargo &lt;int&gt;, ## # descricao_cargo &lt;chr&gt;, tipo_legenda &lt;chr&gt;, nome_coligacao &lt;chr&gt;, ## # composicao_legenda &lt;chr&gt;, sigla_partido &lt;chr&gt;, numero_partido &lt;int&gt;, ## # nome_partido &lt;chr&gt;, qtd_votos_nominais &lt;int&gt;, qtd_votos_legenda &lt;int&gt;, ## # transito &lt;chr&gt; A partir do arquivo importado, iremos agregar os dados por estado e calcular a quantidade de votos para PT e PSDB: eleicoes_agg &lt;- eleicoes %&gt;% filter(ano_eleicao == 2014, num_turno == 2, descricao_cargo == &quot;Presidente&quot;) %&gt;% # agrupar por UF e partido group_by(sigla_uf, sigla_partido) %&gt;% summarise(qtd_votos = sum(qtd_votos_nominais)) %&gt;% # converter para formato wide spread(sigla_partido, qtd_votos, fill = 0) %&gt;% # criar coluna chamada prop_PT, que representa o percentual de votos # para o PT em todos os votos validos no estado mutate(prop_PT = PT/(PT + PSDB)) head(eleicoes_agg) ## # A tibble: 6 x 4 ## # Groups: sigla_uf [6] ## sigla_uf PSDB PT prop_PT ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AC 243677 138982 0.363 ## 2 AL 574322 941445 0.621 ## 3 AM 556545 1033457 0.650 ## 4 AP 142780 227509 0.614 ## 5 BA 2153111 5059860 0.701 ## 6 CE 1068169 3522884 0.767 Com o dataframe de votos criado, podemos o unir com o dataframe que contem os dados espaciais dos estados: estados_eleicoes &lt;- left_join(brmap_estado, eleicoes_agg, by = c(&quot;estado_sigla&quot; = &quot;sigla_uf&quot;)) head(estados_eleicoes) ## Simple feature collection with 6 features and 7 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -73.99045 ymin: -13.6937 xmax: -46.07095 ymax: 5.271841 ## epsg (SRID): 4674 ## proj4string: +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ## # A tibble: 6 x 8 ## cod_regiao cod_estado estado_nome estado_sigla PSDB PT prop_PT ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 11 Rondônia RO 4.43e5 3.64e5 0.451 ## 2 1 12 Acre AC 2.44e5 1.39e5 0.363 ## 3 1 13 Amazonas AM 5.57e5 1.03e6 0.650 ## 4 1 14 Roraima RR 1.40e5 9.74e4 0.411 ## 5 1 15 Pará PA 1.56e6 2.10e6 0.574 ## 6 1 16 Amapá AP 1.43e5 2.28e5 0.614 ## # ... with 1 more variable: geometry &lt;POLYGON [°]&gt; Enfim, podemos proceder com a criação do mapa: ggplot(estados_eleicoes) + geom_sf(aes(fill = prop_PT)) + # mudar escala de cores para sequencial vermelha scale_fill_distiller(type = &quot;seq&quot;, palette = &quot;Reds&quot;, direction = 1) + # deixar o mapa mais limpo e sem eixos theme( legend.position = &quot;bottom&quot;, panel.background = element_blank(), panel.grid.major = element_line(color = &quot;transparent&quot;), axis.text = element_blank(), axis.ticks = element_blank() ) + labs(title = &quot;Proporção de votos válidos para o PT por estado&quot;, fill = NULL) Referências: geom_sf() Tutorial de geom_sf() 4.3 Mapas: plotando pontos com Google Maps O objetivo do pacote ggmap é obter dados de mapas de serviços populares na Internet como o Google Maps e os plotar usando a sintaxe do ggplot2. Contudo, ultimamente a API do Google Maps está muito instável, o que faz com que muitas funções funcionem hora sim hora não. Por esse motivo, não é recomendável usar algumas das funções do ggmap, como geocode(), que transforma um endereço de input em coordenadas geográficas. Felizmente, ainda existem outras funções do pacote que funcionam bem, principalmente quando já se tem em mãos os dados de latitude e longitude, que é o caso do dataset que usaremos aqui. A Prefeitura de São Paulo tem um serviço chamado Cuidando do meu bairro, uma iniciativa de dados abertos que fornece dados de despesas orçamentárias da prefeitura. No código abaixo, baixamos o arquivo: orcamento_sp &lt;- read_csv(&quot;http://devcolab.each.usp.br/dadosorcamentarios/2017.csv&quot;, progress = FALSE) %&gt;% # selecionar colunas importantes select(administracao, ds_categoria, ds_despesa, ds_fonte, ds_funcao, ds_modalidade, ds_orgao, estado, latitude, longitude, pa, papa, vl_atualizado) # dê uma olhada no dataset com a função glimpse() # remover linhas sem latitude e longitude orcamento_sp &lt;- orcamento_sp %&gt;% filter(!(is.na(latitude) &amp; is.na(longitude))) A função get_map() serve para criar um mapa de fundo sobre o qual os pontos serão plotados. São três os principais argumentos que precisam ser definidos: location, que marca o centro do gráfico, o nível de zoom e o maptype. # definir o centro de sao paulo centro_sp &lt;- c(lon = mean(orcamento_sp$longitude), lat = mean(orcamento_sp$latitude)) mapa_sp &lt;- get_map(location = centro_sp, zoom = 11, maptype = &quot;toner-lite&quot;) O objeto mapa_sp já pode ser usado para construir o mapa de fundo, usando a função ggmap(): # plotando o mapa de sao paulo ggmap(mapa_sp) Para adicionar pontos, usa-se a mesma sintaxe do ggplot2, acrescentando camadas de pontos com geom_point() e definindo suas aesthetics: ggmap(mapa_sp) + geom_point(data = orcamento_sp, aes(x = longitude, y = latitude, color = pa)) + facet_wrap(~ ds_categoria) ## Warning: Removed 46 rows containing missing values (geom_point). 4.4 Mapas interativos O pacote leaflet permite que criemos mapas com recursos interativos, com uma sintaxe um pouco diferente da do ggplot2 e ggmaps, porém usando também a sintaxe de camadas. Um mapa básico do leaflet é criado com a seguinte sintaxe: leaflet() %&gt;% addTiles() A função leaflet() inicializa o objeto e addTiles() cria uma camada de mapa. Para adicionar pontos a um mapa, basta usar a função addCirleMarkers(): paleta_cores &lt;- colorFactor(c(&quot;blue&quot;, &quot;red&quot;), unique(orcamento_sp$pa)) leaflet() %&gt;% addTiles() %&gt;% addCircleMarkers( # definir o dataframe de referencia data = orcamento_sp, # usa-se uma sintaxe especial marcada pelo acento til seguido do nome da variavel lng = ~longitude, lat = ~latitude, # adicionar um popup popup = ~ds_fonte, color = ~paleta_cores(pa) ) 4.5 Gráficos de dados hierárquicos: treemaps e sunburst Para um tipo de dados específicos, os hierárquicos, treemaps e sunbursts são ótimas opções de visualização. Suponha que você esteja analisando o seu orçamento pessoal, cujos dados são: orcamento_pessoal &lt;- tribble( ~nivel1, ~nivel2, ~nivel3, ~despesa, &quot;Moradia&quot;, &quot;Aluguel&quot;, NA, 1300, &quot;Moradia&quot;, &quot;Condominio&quot;, NA, 800, &quot;Mercado&quot;, &quot;Alimentação&quot;, &quot;Carnes&quot;, 150, &quot;Mercado&quot;, &quot;Alimentação&quot;, &quot;Vegetais&quot;, 50, &quot;Mercado&quot;, &quot;Mat. de limpeza e higiene&quot;, NA, 100, &quot;Transp&quot;, &quot;Carro&quot;, NA, 400, &quot;Transp&quot;, &quot;Publico&quot;, NA, 150, &quot;Contas&quot;, &quot;Energia&quot;, NA, 130, &quot;Contas&quot;, &quot;Agua&quot;, NA, 60, &quot;Contas&quot;, &quot;Netflix&quot;, NA, 27.90, &quot;Contas&quot;, &quot;Internet&quot;, NA, 80, &quot;Lazer&quot;, &quot;Restaurantes&quot;, NA, 350, &quot;Lazer&quot;, &quot;Cultura&quot;, &quot;Cinema&quot;, 100, &quot;Lazer&quot;, &quot;Cultura&quot;, &quot;Teatro&quot;, 50, &quot;Lazer&quot;, &quot;Cultura&quot;, &quot;Livros&quot;, 90 ) head(orcamento_pessoal) ## # A tibble: 6 x 4 ## nivel1 nivel2 nivel3 despesa ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Moradia Aluguel &lt;NA&gt; 1300 ## 2 Moradia Condominio &lt;NA&gt; 800 ## 3 Mercado Alimentação Carnes 150 ## 4 Mercado Alimentação Vegetais 50 ## 5 Mercado Mat. de limpeza e higiene &lt;NA&gt; 100 ## 6 Transp Carro &lt;NA&gt; 400 Conforme os dados mostram, os dados seguem um padrão hierárquico, pois estão em organizados em categorias (nivel1) que possuem subcategorias (nivel2), que por sua vez possuem subhieraquias menores (nivel3). Qual seria então uma boa maneira de visualizar essa estrutura de dados? Uma alternativa são os treemaps. A função treemap::treemap() também é simples de ser usada: precisamos definir o dataframe no parâmetro dfr, os níveis hierárquicos em index, a variável que define a área dos quadriláteros em vSize e outras customizações: treemap(orcamento_pessoal, # definindo os niveis hierarquicos index = c(&quot;nivel1&quot;, &quot;nivel2&quot;, &quot;nivel3&quot;), # variavel numerica que define o tamanho dos blocos vSize = &quot;despesa&quot;, # titulo title = &quot;Treemap de orçamento pessoal&quot;, # definir estilo da fonte e ajuste vertical para cada um dos niveis hierarquicos fontface.labels = c(&quot;oblique&quot;, &quot;bold&quot;, &quot;italic&quot;), ymod.labels = c(0.6, 0, 0) ) Outra alternativa é o gráfico do tipo sunburst, que lembra um gráfico de pizza. Para fazer um gráfico sunburst, é preciso concatenar as colunas de níveis hieráquicos com um traço. Observe o exemplo fornecido na documentação do pacote: # ?sunburst # exemplo tirado da documentação: sequences &lt;- read.csv( system.file(&quot;examples/visit-sequences.csv&quot;,package=&quot;sunburstR&quot;) ,header = FALSE ,stringsAsFactors = FALSE )[1:100,] # observe a estrutura de dados head(sequences) ## V1 V2 ## 1 account-account-account-account-account-account 22781 ## 2 account-account-account-account-account-end 3311 ## 3 account-account-account-account-account-home 906 ## 4 account-account-account-account-account-other 1156 ## 5 account-account-account-account-account-product 5969 ## 6 account-account-account-account-account-search 692 # o sunburst é produzido com a função homônima: sunburst(sequences) Legend Para concatenar nosso dataframe de orçamento do exemplo, usamos a função tidyr::unite(), que como o nome fala, junta várias colunas em uma só. orcamento_pessoal_sb &lt;- orcamento_pessoal %&gt;% unite(hierarquia, nivel1:nivel3, sep = &quot;-&quot;) sunburst(orcamento_pessoal_sb) Legend Percebeu como os níveis 2 que não possuem um nível 4 foram trocados por um NA, prejudicando o visual do gráfico? Por isso, recomenda-se substituir os NAs por um caracter vazio (“”). orcamento_pessoal %&gt;% mutate(nivel3 = ifelse(is.na(nivel3), &quot;&quot;, nivel3)) %&gt;% unite(hierarquia, nivel1:nivel3, sep = &quot;-&quot;) %&gt;% sunburst() Legend 4.6 Exercícios Carregue os pacotes usados no material deste módulo plotly Carregue o dataset series_ipca_selic.rds. Filtre os dados a partir de 01/01/2000 e faça um gráfico simples de linha dos indicadores, mapeando a coluna de indicador na aesthetic cor. Salve o gráfico no objeto p2. Transforme o gráfico para interativo usando a função ggplotly. Brinque com o gráfico: dê zoom em períodos específicos, passe o mouse nas linhas, etc. Confira como ficou a tooltip. Volte ao gráfico original e defina uma aesthetic text de forma que mostre a data em um formato mm/aaaa, o nome do indicador e seu valor. Salve o gráfico finalizado em um arquivo local com a extensão html. geom_sf Execute o código abaixo para baixar o conjunto de dados da quantidade de servidores civis e total remunerado para os mesmos por estado (dados de Junho/2018): # https://github.com/sillasgonzaga/postsibpad/blob/master/data/servidores_agregados_por_uf.csv df_servidores &lt;- read.csv2(&quot;https://raw.githubusercontent.com/sillasgonzaga/postsibpad/master/data/servidores_agregados_por_uf.csv&quot;) Crie um novo dataframe chamado df_servidores_estado, que corresponde à junção do dataframe brmap_estado, do pacote brmap, com df_servidores. Crie dois mapas: um com os estados coloridos pela quantidade de servidores e outro pelo log da remuneração bruta. "],
["apresentacao-de-dados-com-relatorios.html", "Módulo 5 Apresentação de dados com relatórios 5.1 Primeiros passos com R Markdown 5.2 Resumo da sintaxe Markdown 5.3 Chunks 5.4 Formatos de output 5.5 Compilando um documento rmarkdown 5.6 Produzindo tabelas no R Markdown 5.7 Relatórios parametrizados 5.8 Projeto final", " Módulo 5 Apresentação de dados com relatórios library(tidyverse) R Markdown, ou simplesmente rmarkdown, é a ferramenta perfeita para transformar suas análises em documentos, relatórios, apresentações e até mesmo dashboards de alta qualidade e de maneira programática. Foi desenvolvida para facilitar a reprodução de resultados, visto que tanto código quanto narrativa estão no mesmo documento, e os resultados são automaticamente gerados do código presente no documento. Com R Markdown, é possível: Compilar um documento em um relatório em diferentes formatos de saída, como PDF, HTML e Word. Produzir slides para apresentações. Criar dashboards interativas, com layouts atraentes e que se adaptam à tela do usuário. Criar relatórios interativos com Shiny. Escrever artigos científicos ou livros. Criar blogs ou sites. Referências: * Cheatsheet do R Markdown * Guia de referência do R Markdown 5.1 Primeiros passos com R Markdown No Rstudio, acesse os menus File &gt; New File &gt; R Markdown… e clique em OK para criar um novo documento R Markdown com formato HTML. Você verá o seguinte documento: Na imagem acima, podem ser vistos os três componentes básicos de um documento R Markdown: Metadados, escritos no cabeçalho entre o par de três traços (—). A sintaxe para o cabeçalho segue a sintaxe YAML; Texto (partes em branco no exemplo), que segue a sintaxe Markdown; Código (partes nos blocos em cinza, chamados chunks), que segue a sintaxe da linguagem especificada no cabeçalho do bloco (por padrão é R). Um chunk de código é criado por um par de três aspas, como em ```{r}, onde r indica a linguagem do código. 5.2 Resumo da sintaxe Markdown 2.5 Markdown syntax O R Markdown, como visto, pode ser usado como editor de textos, que seguem a sintaxe da linguagem Markdown 5.2.1 Formatação de texto Os principais tipos de formatação de texto em Markdown e suas respectivas sintaxes são: Textos em itálico são produzidos com um par de asteriscos *Itálico* ou de underscores _Itálico_ Textos em negrito são produzidos com dois pares de asteriscos :**Negrito** Um par de acentos til produz texto subscrito: CO~2~ vira CO2 Um par de acentos circunflexos produz texto sobrescrito: x^2^ vira x2 Hyperlinks são criados com a sintaxe [texto](link): Clique [aqui](https://www.google.com/) vira Clique aqui Imagens são inseridas com a sintaxe ![texto opcional](pasta/imagem.jpg) ou ![texto opcional](link para imagem) 5.2.2 Cabeçalhos Cabeçalhos de capítulos (seções) e subcapítulos são criadas de maneira hierárquica, de acordo com a quantidade de jogos-da-velha usados. Quanto maior o número, menor a hierarquia: # Cabeçalho do Nível 1 ## Cabeçalho do Nível 2 ### Cabeçalho do Nível 3 Mais links para aprender mais sobre a linguagem Markdown: * https://blog.da2k.com.br/2015/02/08/aprenda-markdown/ * https://github.com/luongvo209/Markdown-Tutorial/blob/master/README_pt-BR.md 5.3 Chunks Chunks são os blocos de código que são executados quando o documento é compilado. É possível criar um novo chunk no menu Insert &gt; R ou usando o atalho Ctrl + Alt + I. Qualquer tipo de output pode ser produzido a partir de um chunk, como textos, tabelas ou gráficos. Caso seja necessário ter um controle maior sobre os outputs, podem ser usadas opções no cabeçalho do chunk, como no exemplo abaixo: ```{r nome-opcional-do-chunk, fig.height=7, fig.width = 11, warning = FALSE} Com as opções acima, configuramos as dimensões de altura e largura do gráfico de output e definimos que mensagens do tipo warning (como quando o ggplot2 avisa que dados NA foram descartados) não serão mostradas no documento final. São várias as opções de chunks. Algumas das principais são: eval: tipo logical. Executar (TRUE) ou não (FALSE) o código do chunk. echo: tipo logical. Incluir o código do chunk ou não no documento compilado. warning, message e error: tipo logical. Caso error = TRUE, o documento será compilado mesmo que o chunk retorne um erro. include: tipo logical. Controla se o chunk e o output estarão presentes no documento final. cache: tipo logical. Controla se o chunk poderá usar cache para criar uma pasta com arquivos cacheados. Útil para chunks de códigos que levam muito tempo para rodar. Caso você deseje que uma opção seja definida da mesma maneira para todos os chunks do documento, como para definir um tamanho padrão para os gráficos, você pode criar um chunk global no início do documento e definindo essas opções na função knitr::opts_chunk$set(), como no exemplo abaixo: markdown{r, setup, include=FALSE} knitr::opts_chunk$set(fig.width = 8, collapse = TRUE) ``` Referências: * Documentação completa das opções de chunks 5.4 Formatos de output Os principais formatos, que podem ser categorizados em documentos ou apresentação, são: beamer_presentation html_document ioslides_presentation pdf_document slidy_document powerpoint_presentation word_document Cada formato de output aceita diversas opções de customização, como incluir sumário, numerar capítulos, o tema, etc. Para conhecer todas as opções de um formato de output, recomenda-se ler a documentação da respectiva função, como ?rmarkdown::html_document. As opções do formato de output podem ser definidas no YAML do documento, como no exemplo abaixo: output: html_document: toc: true number_sections: yes pdf_document: keep_tex: true 5.5 Compilando um documento rmarkdown Após escrever o texto e criar o código desejados, o documento pode ser compilado usando o botão Knit no Rstudio ou com o atalho Ctrl + Shift + K. Ambos são um atalho para a função rmarkdown::render(). Com isso, o documento será compilado no formato de output especificado no YAML e será criado um arquivo com o mesmo nome na mesma pasta do arquivo .Rmd. 5.6 Produzindo tabelas no R Markdown Existem três boas opções para produzir tabelas elegantes em documentos R Markdown: A função knitr::kable() iris %&gt;% head() %&gt;% knitr::kable() Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa A função formattable::formattable(): iris %&gt;% head() %&gt;% formattable::formattable() Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa A função knitr::kable() acompanhada do pacote kableExtra: iris %&gt;% head() %&gt;% kableExtra::kable() Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa Tabelas interativas com o pacote DT: iris %&gt;% head() %&gt;% DT::datatable() Referências: Tutorial do pacote kableExtra Tutorial do pacote formattable Mais um tutorial do pacote formattable Site do pacote 5.7 Relatórios parametrizados Uma excelente maneira de automatizar processos de geração de relatórios para diferentes variáveis é utilizando o recurso de parametrização de relatórios. Alguns exemplos de quando esse tipo de situação é útil: Mostrar resultados apenas para um específico departamento de uma empresa, gerente, ou região geográfica. Rodar um relatório que cobre um período de tempo específico. Controlar globalmente algumas opções do documento, como a presença ou não do código no documento final. 5.7.1 Declarando parâmetros Parâmetros são introduzidos e especificados usando o campo params dentro do YAML, como no exemplo abaixo: --- title: Relatório Semestral output: html_document params: ano: 2018 estado: SP arquivo: vendas.csv --- 5.7.2 Usando os parâmetros Após a definição dos parâmetros, é criada na sessão R um objeto do tipo lista chamado params, que contem as variáveis e seus valores definidos no YAML. Para acessá-los, basta usar a sintaxe padrão de uma lista: params$ano params$estado Para compilar um relatório com parâmetros definidos, a melhor maneira (num ponto de vista programático) é usar a função rmarkdown::render() definido o argumento params. Por exemplo, suponha que criamos um documento com o YAML anterior e o salvamos no arquivo meu_relatorio.Rmd. Para compilar o documento e produzir o output final com os devidos parâmetros, usaríamos a seguinte sintaxe: rmarkdown::render(&quot;meu_relatorio.Rmd&quot;, params = list( ano = 2018, estado = RJ )) Note que não foi necessário definir um valor para o parâmetro arquivo pois já existe um valor default definido no YAML. 5.8 Projeto final Vamos simular uma situação muito comum em organizações: Você é cientista de dados na ONU e lhe foi pedido para elaborar um relatório descritivo de algumas estatísticas por países de cada continente (sem Oceania). Contudo, você deve elaborar um relatório contendo apenas dados de cada continente, criando um arquivo separado para cada. Crie um novo arquivo .Rmd chamado relatorio_onu.Rmd No YAML do relatório, acrescente o parâmetro continente_relatorio. Crie um relatório que execute estas tarefas: Carregue os pacotes tidyverse e gapminder, do pacote gapminder. Use data(gapminder). Filtre o continente definido no parâmetro e salve no objeto chamado df_relatorio. Crie um chunk com histograma da expectativa de vida dos países no ano de 2007. Crie um chunk com um gráfico de linha mostrando a mediana do PIB per capita do continente por ano. Crie um chunk com um gráfico de colunas mostrando os 10 piores países em PIB per capita em 2007. Ordene as colunas em função do PIB per capita e inverta os eixos do gráfico. Crie um chunk com uma tabela mostrando os 10 países mais populosos em 2007. Salve e feche o relatório. Abra um novo arquivo R script. Carregue o dataset gapminder, extraia os nomes dos continentes presentes no dataset, salve em um vetor e exclua a Oceania (você pode usar a função stringr::str_remove() para isso). Lembre de converter o vetor de continentes para character. Use a função rmarkdown::render() especificando o continente em params. Crie um for loop para gerar um relatório para cada continente, salvando com o respectivo nome. "]
]
